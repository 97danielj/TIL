[toc]

# C언어 수업 이전 배경 지식

---

컴퓨터는 일련의 연산을 수행하는 **계산기**입니다.

> 차이점은 컴퓨터는 스스로 명령어를 읽어 들여서 연산 수행이 가능합니다. 

그럼 떠오르는 의문들

1. 누가 명령어를 읽는가?
2. 어디서 명령어를 읽는가?
3. 프로그램이란게 뭐지?
4. 명령어는 어떻게 작성하는가?



## 누가 명령어를 읽는가

---

컴퓨터의 모든 연산은 `중앙처리장치(cpu)`의해서 처리됩니다.

CPU는 약 1초에 10억번의 연산을 처리하는 만큼 엄청난 양의 열을 발생합니다. 보통 쿨러라는 냉각장치 밑에 숨어 있습니다.

- GPU: 그래픽 관련 연산들만 전문적으로 처리(행렬 연산 전문)



## 어디서 명령어를 읽는가

---

> 메모리는 계층 구조로 되어 있고, 더 접근 빠를 수록, 용량이 작다.

자 이제 컴퓨터에 모든 명령어들은 CPU에서 처리된다는 것을 배웠습니다. CPU가 명령어를 실행하기 위해서는 두 가지조건이 필요합니다.

1. 실행할 명령어를 읽어야 하고
2. 연산된 결과를 어디엔가 저장해야 합니다.

CPU는 연산에 특화되어 있는 장치이기 때문에 데이터를 저장해놓을 **공간이 매우 부족하다**라는 점입니다.

CPU가 연산을 수행하기 위해서는 **데이터를 저장하는 공간**을 `레지스터(register)`라고 부르는데, 우리가 일상적으로 사용하는 64비트(8바이트) CPU경우 레지스터 총 16개 밖에 없습니다.

> 정확히 말하자면 x86-64 아키텍쳐의 CPU 를 말합니다. 물론 다른 아키텍쳐의 CPU 들도 크게 상황이 다르지는 않습니다. 예를 들어서 요즘 핫한 ARM64 의 경우 31 개의 레지스터가 사용됩니다.

각 레지스터에는 64비트의 데이터를 담을 수 있죠. 레지스터는 CPU안의 메모리 이기 때문에 CPU안에서 연산 수행시 매우 빠르게 접근 가능하지만 기술 한계상 레지스터 개수는 늘리기 어렵기 때문에 CPU외부에 저장공간을 생성

이렇게 CPU옆에 딱 붙어서 저장 공간 역할을 하는 장치를 바로 램(RAM) / 임의 접근 메모리 (Random Access Memory) 의 줄인 말인데, 왜 *임의 접근* 인지는 아래에서 후술하겠습니다.



보통 램의 8GB정도이고, 연산을 수행시 램에서 읽어들이게 됩니다. 필요한 데이터는 램에서 꺼내 쓰거나 저장해놓죠.

하지만 이런 램은 `휘발성 메모리`라는 단점을 가지고 있습니다. 

> 휘발성 메모리: 전기가 있을 경우에만 유지되는 메모리, 전원 공급 없으면 저장된 데이터는 소실

이러한 단점을 보완하기 위해 컴퓨터가 꺼져도 데이터를 유지할 수 있는 저장장치가 필요하는데, 이 때 등장하는 것이 바로 하드디스크와 SSD입니다.

1. 하드 디스크에서 저장되어 있는 프로그램의 위치를 찾아서 램에 복사해놓는다.
2. CPU 는 램에서 명령어를 읽어들여서 실행을 한다.

순으로 진행이 된다고 보시면 됩니다.

CPU 에서 램에 있는 데이터를 가져오는데 **100 나노초**가 걸린다고 보는데, SSD 의 경우 대략 50 ~ 150 마이크로초, 하드 디스크의 경우 무려 1 ~ 10 밀리초가 걸립니다. 참고로 1 밀리초는 1000 마이크로초이고, 1 마이크로초는 1000 나노초 입니다.

CPU 는 **평균적으로 0.3 나노초 마다 1 번 연산**을 수행하는데, 하드 디스크에서 데이터가 올 때 까지 기다리는 동안 대략 3천만 번의 연산을 수행할 수 있습니다. 만일 CPU 가 매번 하드 디스크에서 필요한 명령어를 읽어들인다면 엄청난 시간을 낭비하게 되겠죠! 따라서 보통 컴퓨터 프로그램을 실행을 한다

보통 컴퓨터 프로그램을 실행을 한다면

1. 하드 디스크에 저장되어 있는 프로그램 위치를 찾아서 램에 복사
2. cpu는 램에서 명령어를 읽어들여서 실행을 한다.

![img](https://modoocode.com/img/c/cpuramhdd.png)

RAM이 있다 하지만 50나노초는 CPU에서 150번수행 가능합니다. 생각보다 엄청 깁니다.

이러한 문제 때문에 CPU는 비록 직접적인 연산을 수행할 수 는 없지만 빠르게 데이터를 레지스터에 불러올 수 있는 저장 공간으로 `캐시(Cache)`라는 것을 사용합니다. 

캐시는 **계층별로 L1, L2, L3** 캐시로 이루어져 있는데, L1 캐시의 경우 크기가 제일 작지만 (보통 256KB) 레지스터와 가장 인접한 캐시로 L1 캐시에 저장되어 있는 데이터를 읽는 데에는 1 나노초 밖에 걸리지 않습니다.

따라서 데이터를 읽어들이는데 기다리는 시간을 최소화 할 수 있죠. L3 캐시의 경우 대충 28 나노초 정도 걸리지만 크기가 제일 큽니다 (~ 16MB). 따라서 보통 **지금 가장 필요한 데이터** 의 경우 L1 캐시에 들어가게 되고, 그 중요도에 따라 필요성이 낮으면 낮을 수록 L2, L3 캐시에 배치됩니다.

> 데이터 중요도에 따라 **계층별로 L1, L2, L3** 들어간다.

CPU 는 자기가 조만간 사용할 것만 같은 데이터들을 미리 캐시에 불러옵니다. 또한 램에 데이터를 저장할 때도, 바로 램에 쓰는 것이 아니라 캐시에만 잠깐 써놨다가 나중에 (여유가 좀 생기면) 램에 적는 방식을 사용하곤 합니다.

물론 CPU 가 요청한 데이터가 캐시에 없을 수 도 있습니다. 이를 캐시 미스(Cache miss) 라고 하며, 이 경우 램에서 필요한 데이터를 불러 오느라 상당히 시간이 지체됩니다. 빠르게 동작하는 프로그램을 설계하기 위해서는 캐시 미스 확률을 낮게 하는 것이 중요하겠죠

| | 실제 접근 시간   | 현실 시간으로 환산했을 때            |
| ---------------------------------------------------- | ------------------------- | ----------- |
| 1 CPU 사이클 (가장 간단한 연산을 하는데 걸리는 시간) | 0.4 **나노초**            | 1초         |
| L1 캐시 접근                                         | 0.9 나노초                | 2초         |
| L2 캐시 접근                                         | 2.8 나노초                | 7초         |
| L3 캐시 접근                                         | 28 나노초                 | 1분         |
| RAM 접근                                             | ~100 **나노초**           | 4분         |
| NVMe SSD 접근                                        | ~25 마이크로초            | 17시간      |
| 일반 SSD 접근                                        | 50~150 **마이크로**초     | 1.5일 ~ 4일 |
| 일반 하드디스크 접근                                 | 1~10 밀리초               | 1 ~ 9달     |
| 서울에서 미국 샌프란시스코 패킷 전송 시간            | 180ms                     | 14년        |

## 명령어는 어떻게 작성하는가?

---

CPU가 램에서 데이터를 읽어들이기 위해서는 **램의 어디에서 데이터를 읽어들일지 말해줘야**합니다.

CPU는 알아듣는 명령어 체계(명령어 집합) `ISA`

1. X86: intel, amd
2. ARM
3. RISK-V

서로 준수하는 명령어 집합이 다르기 때문에 명령어가 호환되지는 않는다.

CPU가 램에서 데이터를 읽어들이기 위해서는 램의 어디에서 데이터를 읽어들이지 말해줘야 하빈다.

램에 있는 모든 데이터는 1 바이트 단위로 0 번을 시작으로 고유의 **주소(address)** 가 부여되어 있습니다.

![img](https://modoocode.com/img/c/ram2.png)

위 그림은 램의 모습을 간단하게 나마 그려본 것입니다. 위와 같이 램은 크기가 1 바이트 (2진수로 8 자리 수) 짜리 데이터를 보관할 수 있는 수 많은 방들로 구성되어 있습니다. CPU 는 램에게 *어디에서* 데이터를 읽을지 알려준다면 램은 해당 위치에 있는 데이터를 즉각 전달해줍니다

> 주소는 16진수로 표기되는게 이해 싶다.

마찬가지로 *어디에다* 데이터를 저장할지 알려준다면 램은 해당 위치에 있는 데이터를 CPU 가 전달한 데이터로 바꿔치기 합니다 (그 위치에 있던 데이터는 사라집니다.)

한 가지 중요한 점은 해당 주소값으로 부터 **얼마 만큼** 읽어야 할지도 말해줘야 한다는 것입니다. 램 상에서는 데이터의 경계가 없습니다. 예를 들어서 0x1234 라는 주소값에서 부터 단 한칸 (즉 1 바이트) 만 읽어야 할 수도 있고, 4 칸 (4 바이트) 를 읽어야 할 수 도 있습니다. 이렇게 얼마 만큼 읽어야 할 지는 명령어 단계에서 지정해줍니다.

예를 들어 우리가 CPU 에게 주소값 0x1234 에 1 바이트 만큼 3 이라는 데이터를 저장하고 싶다고 해봅시다. 그렇다면 다음과 같은 순서로 명령어를 내리면 됩니다.

- 먼저 CPU 의 레지스터에 접근하고자 하는 주소값 0x1234 를 저장합니다. 편의상 a 라는 레지스터에 저장했다고 해봅시다.(주소 저장) - 
- 이제 *a 에 저장된 주소값에서 부터 1 바이트 부분 까지 3 을 저장해* 라는 명령을 내립니다.(명령 실행)

그렇다면 CPU 는 레지스터 a 에 저장되어 있는 주소값인 0x1234 에, 3 이라는 데이터를 저장하라는 명령을 실행하게 됩니다. 따라서 램에는 3 이라는 데이터가 들어가겠죠.

![img](https://modoocode.com/img/c/ram3.png)

명령어는 이진수이기 때문에 사람이 이해하기 쉽게 변형된 명렁어를 어셈블리어라고한다.

```assembly
mov eax, 4660 #4660은 0x1234십진표기
mov BYRE PTR [rax], 3 #eax는 레지스터 rax의 하위 4바이트
mov A, B # B의 값을 A에 복사해라
```

## CPU 가 명령어를 읽어들이는 방법

---

자, 앞서 간단하게 CPU 가 어떠한 방식으로 램에 데이터를 읽고/쓰는지에 대해서 살펴보았습니다. 정리해보자면 CPU 는 **주소값** 을 통해서 램에 어디에 접근할지 명령하게 됩니다.

그런데, CPU 가 독자적으로 명령을 내릴 수 있는 것은 아닙니다. CPU 가 명령을 내리기 위해서는 해당 명령어를 어디선가 가져와야 합니다. 이와 같이 CPU 에 실행할 명령어를 제공하는 것을, 쉬운 말로 **프로그램을 실행한다** 라고 합니다.

프로그램은 단순히 생각해보면 실행할 명령어와 데이터들의 집합이라 보시면 됩니다. 우리가 프로그램을 실행하게 되면, 컴퓨터의 `운영체제`가 CPU 에게 램에 위치해 있는 프로그램의 시작점을 알려주게 되고, 그 이후로 CPU 는 해당 위치 부터 명령어를 쭉쭉 읽어나가며 실행하게 됩니다.

여기서 중요한 점은 CPU 가 **현재 램의 어디에서 명령어를 읽어야 할지** 계속 알아야 한다는 점입니다. 이는 CPU 안에 **지금 읽어들일 명령어의 위치 (instruction pointer)** 만을 보관하는 특별한 레지스터 덕분에 가능하며, 인텔 64 비트 CPU 의 경우 해당 레지스터의 이름은 `RIP` 입니다.

![img](https://modoocode.com/img/c/instruction.png)

예를 들어서 위와 같이 간단한 프로그램이 메모리에 들어가 있다고 해봅시다. 만일 현재 RIP 가 0x40068 이라면, CPU 는 메모리에서 해당 위치에 쓰여 있는 명령어를 읽게 됩니다. 이 경우 `mov rax, 0x20` 이 되겠네요.

해당 명령어를 처리하고 나면 rax 에는 0x20 이 들어가겠고, RIP 는 그 다음 명령어를 가리키는 주소값인 0x4006b 로 **자동으로 업데이트** 됩니다.

CPU 는 현재 내가 어떠한 프로그램을 실행하고 있는지 모릅니다. 그저 현재 자신의 RIP 레지스터가 가리키는 위치에 있는 명령어를 실행하고 그 다음 명령어의 위치로 RIP 를 증가시키는데에만 관심이 있을 뿐 어떠한 프로그램에서 해당 명령어를 실행하는지 모릅니다.

그렇다면 예를 들어서 우리가 컴퓨터에서 스타크래프트를 실행하였다고 해봅시다. 그렇다면 누군가는 하드 디스크나 SSD 와 같은 저장 장치에 있는 스타크래프트 프로그램 파일을 메모리에 복사하는 작업을 해야 겠죠? 이와 같은 과정은 `운영체제` 단에서 해결합니다.

한 가지 중요한 점은 메모리에 *아 여기는 명령어들이 있는 곳이고 여기는 데이터들이 있는 곳이다* 라고 써있는 것이 아닙니다. 따라서 CPU 의 관점에선 메모리의 특정 주소값을 읽으라고 했을 때 뭐가 데이터이고 뭐가 프로그램 명령어 인지 알 수 없습니다. 그냥 운영체제가 프로그램에서 처음으로 실행할 명령어의 위치를 CPU 에게 알려주고 난다면, 그냥 그려러니 하고, 거기서 부터 명령어들을 쭉쭉 읽어나가게 됩니다. CPU 는 이렇게 생각보다 단순합니다.

## 그런데 프로그램이 하나만 실행하는게 아니잖아?

---

앞선 그림에서는 우리가 딱 스타크래프트 하나만을 실행하는 것을 생각했지만, 실제로는 컴퓨터 상에서 한 번에 프로그램 하나만이 돌아가고 있는 것이 아니지요. 일단 이 글을 보시는 분들은 아마 인터넷 브라우저를 돌리고 있을 테고, 당연히 운영체제 자체도 프로그램으로써 메모리에 상주해있을 것입니다. 따라서 실제 RAM 을 살펴보자면 아래와 같이 여러가지 프로그램들이 각각에 구역에서 뒤영켜 있을 것입니다.

![img](https://modoocode.com/img/c/ram5.png)

위 그림은 실제로 여러 프로그램들이 같이 실행되고 있을 때 램의 모습을 나타낸 것입니다. 각 프로그램들이 램의 여러 부분을 나누어서 돌아가고 있음을 알 수 있습니다.

앞서 간단하게 어셈블리 명령어를 다루면서, CPU 에서 원하는 위치에 데이터를 쓰거나 가져오기 위해서는 메모리의 *주소값* 을 전달해야 한다고 하였습니다.

```asm
        mov     eax, 4660
        mov     DWORD PTR [rax], 3
```

예를 들어서 위 명령어는 메모리의 0x1234 (십진수로 4660) 에 위치해 있는 곳에서 4 바이트 만큼의 공간에 3 이라는 값을 쓰라는 명령이지요.

그런데 한 가지 문제점이 있습니다. 위와 같이 램에서 여러가지 프로그램들이 돌아가고 있는데 어떻게 0x1234 라는 공간을 사용할 수 있다고 보장할 수 있을까요?

물론, 만약에 지금 0x1234 라는 위치에 있는 공간을 어떤 프로그램도 사용하지 않고 있기에 3 이라는 값을 잘 써 넣을 수 있다고 해봅시다. 그런데 이전에 이미 실행되고 있던 프로그램이 0x1234 부분을 사용하고 있다고 하면 어떻게 될까요? 만일 위 코드가 그대로 실행되었더라면 다른 프로그램의 데이터를 손상시키게 되겠죠.

이를 해결하기 위해서는 다른 메모리 주소를 사용하도록 프로그램 명령어 자체를 다시 작성해야 하는데, 이를 프로그램을 실행할 때 마다 매번 하는 것은 불가능하다고 말할 수 있습니다.

따라서 CPU 에서는 메모리를 조금 더 효율적으로 관리하기 위해서 특별한 메커니즘을 제공합니다.

## 가상 메모리 vs 물리 메모리

실제로 CPU 가 보는 0x1234 라는 주소값과 실제 메모리의 0x1234 주소값은 차이가 있습니다. CPU 가 참조하는 0x1234 라는 주소값은 특별한 `1 대 1 변환 과정`에 의해서 실제 메모리의 주소값을 변환하게 됩니다. 이렇게 변환된 주소는 0x1234 가 될 수 도 있고 아니면 아예 0x12345678 처럼 전혀 다른 곳에 있는 메모리 주소값이 될 수 도 있습니다.

아무튼 CPU 가 참조하는 메모리 주소값을 **가상 메모리(virtual memory)** 라고 하고, 일련의 변환 과정에 의해 참조하게될 실제 메모리의 주소값을 **물리 메모리(physical memory)** 라고 합니다.

![img](https://modoocode.com/img/c/star2.svg)

이러한 변환 방식을 **페이징(paging)** 이라고 하고, 변환이 되는 최소의 메모리 단위를 **페이지(page)** 라고 합니다. 페이지의 크기는 여러가지로 설정할 수 있지만 대부분의 경우 1 페이지는 4 KB 정도 입니다.

어떻게 변환을 수행할 지 기록한 테이블을 **페이지 테이블(page table)** 이라고 하는데, 이 페이지 테이블은 각 프로그램 마다 하나씩 가지고 있습니다. 이 덕분에 구글 크롬에서의 0x1234 와 그림판의 0x1234 가 실제로는 다른 물리 메모리 주소를 참조할 수 있겠죠.

![img](https://modoocode.com/img/c/star3.svg)각 프로그램 별로 고유의 페이지 테이블을 가지고 있기 때문에, 같은 가상 메모리 주소를 사용해도 다른 물리 주소를 의미할 수 있습니다.

반면에 우리가 흔히 사용하는 메모리의 크기는 8 기가 혹은 16 기가 바이트를 주로 사용하죠. 하지만 페이징 덕분에 264264 바이트 가상 메모리 공간 그 어디에 기록을 해도 페이지 테이블을 통해 현재 내가 사용 가능한 크기 이내의 물리 주소로 변환을 하게 되면 문제 없이 사용 가능 합니다.

심지어 경우에 따라선, 메모리의 올라가 있는 전체 프로그램이 필요로 하는 메모리가 지금 내가 가지고 있는 물리 메모리의 용량 보다도 더 큰 경우도 해결 가능합니다. 아무래도 꽤 오래전부터 (메모리가 1기가 밑인 시절) 컴퓨터를 사용해왔던 분들은 기억 하실지 모르겠지만, 메모리가 제한된 환경에서는 이와 같은 상황이 빈번하게 일어났습니다. 만일 프로그램이 요구하는 메모리에 비해서 현재 사용 가능한 메모리가 적다면, 안쓰는 페이지 부터 하드 디스크에 복사해 놓고, 해당 페이지를 메모리를 필요로 하는 프로그램에 제공을 하는 것입니다.

만약에 하드 디스크에 복사해놓은 페이지를 다시 필요로 한다면, 그 때 운영체제가 해당 페이지를 다시 메모리에 복사해주면 됩니다. 옛날 컴퓨터에서 프로그램을 실행했을 때 종종 매우 느려졌던 이유가 바로, 물리 메모리가 부족해서 하드 디스크에 복사해 놓은 페이지를 읽어오느라 매우 느렸던 것입니다. (앞서 이야기 했듯이 메모리에 비해 하드 디스크는 매우 느리죠!)

이렇게 페이징 덕분에 각 프로그램들은 마치 자기 혼자서 메모리 전 공간을 사용하는 것 마냥 생각할 수 있습니다. 메모리에 같이 올라가 있는 다른 프로그램들을 전혀 고려할 필요 없이 말이지요! 덕분에 프로그램을 개발하는 사람들 입장에선 매우 편리하게 프로그램을 작성할 수 있게 되었습니다.

## 정리

- 모든 연산은 CPU 에서 수행된다. 정확히 말하자면, CPU 의 자그마한 레지스터 상에서 수행된다. 64 비트 CPU 의 경우 레지스터의 크기는 8 바이트 이다. 대체로 16개
- CPU는 무슨 연산을 할 지 알려주는 명령어와 명령어 실행을 위한 데이터를 메모리(램)에서 읽어 들어들인다.
- 우리가 프로그램을 실행한다는 것은 하드 디스크에 잠들어 있는 명령어들과 데이터를 메모리에 쓰는 것이라고 생각하면된다. 그리고 운영체제가 CPU에 처음으로 실행해야 할 명령어의 주소값을 전달함(RIP)으로써 프로그램이 시작된다.
- CPU 에는 캐시가 있어서 메모리 접근 횟수를 줄일 수 있다.
- 각 프로그램들은 마치 자신이 방대한 메모리 공간 전체를 사용하는 것 처럼 생각하며 작동한다.(페이징 기법)
- CPU 에서 참조하는 주소값은 실제 물리 메모리 주소값이 아니라 가상 메모리 주소값이다.
- 가상 메모리 주소값은 각 프로그램의 페이지 테이블을 통해서 실제 메모리 주소값으로 변환된다