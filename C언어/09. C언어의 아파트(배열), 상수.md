# C언어의 아파트 (배열), 상수

---

한 꺼번에 여러 개의 변수들을 다뤄야 한다면 어떨까요? 예를 들어서 `int` 변수가 10 개가 필요하다면 말이죠.

```cpp
int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10;
```

이렇게 한다면 가능하겠지만

1. 매 번 변수 이름들을 저렇게 나열하는 것이 복잡하고
2. 해당 변수들을 가지고 작업하는 것도 불편합니다.(예를 들어서 위 변수들을 모두 더하려면? `a1 + a2 + ... + a10` 까지 써야 겠죠.)



따라서 C 언어에서는 여러 개의 변수를 한 꺼번에 다루는, 즉 컴퓨터 **메모리 상에 같은 타입의 변수를 연속적으로 여러 개를 한 꺼번에 정의**할 수 있는 방법을 제공하고 있는데 이를 바로 **배열(Array)** 이라고 합니다.

예를 들어서 `int`형 배열의 경우, `int`형 변ㅂ=수들을 메모리상 연속적으로 여러 개 존재한다고 보시면 됩니다.

## 배열의 기초

```c
#include <stdio.h>

int main(){
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    printf("Array 3 번째 원소 : %d \n", arr[2]);
    return 0;
}
```

실행 결과

```
Array 3 번째 원소 : 3 
```

배열은 말그대로 **특정한 형*(Type)의 변수들의 집합** 입니다. 이전에 변수를 정의할 때에는

```
(변수의 형) (변수의 이름);
```

과 같이 정의했는데 배열은 그와 비슷하게도

```
(배열의 형) (배열의 이름)[원소 개수];
```

와 같이 해주면 됩니다. 위의 경우

```c
int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
```

참고로 이 방법은 배열의 정의 부분에서만 가능하고, 이미 정의된 배열에서는 사용할 수 없습니다. 예를 들어서

```cpp
int arr[3] = {1, 2, 3};  // 가능

arr = {4, 5, 6};  // 불가능! 컴피알 오류
```

또한 배열 정의시 `= { }`로 원소들을 정의했다면 배열의 크기를 생략하면 원소의 개수에 맞게 컴파일러가 알아서 배열을 정의해줍니다.

```c
int arr[] = {1, 2, 3,4 }
int arr2[] = {1, 2, 3, 4, 5, 6}
```

#### 배열에서의 원소 접근

배열의 각각의 원소들에 접근하는 방법은 간단합니다. 배열의 `n` 번째 원소의 접근하기 위해서는 `arr[n - 1]` 와 같이 써 주시면 됩니다. 즉, 대괄호 `[]` 안에 접근하고자 하는 원소의 **(번째수 - 1)** 을 써주면 되죠. 예를 들어서

```cpp
printf("Array 3 번째 원소 : %d \n ", arr[2]);
```

이라고 하면 배열의 3 번째 원소인 3 를 출력하게 됩니다. 많은 사람이 헷갈리는 부분인데, `arr[2]` 라고 하게되면 배열의 2 번째 원소인 2 를 출력하게 될 줄이라고 생각하지만 사실 3 번째 원소가 출력되게 됩니다. 다시 말해 `arr[0]` 은 배열의 첫 번째 원소인 1 이 출력되고 `arr[9]` 는 배열의 10 번째 원소인 10 이 출력되게 됩니다. **C 에서 배열의 원소들은 0 번 부터 셈하는 것이라 생각하면 됩니다.**

주의 사항

>  배열의 n 번째 원소는 `arr[n - 1]` 입니다. 즉 배열의 첫 번째 원소는 `arr[0]` 입니다.

## 배열의 위험성

---



```c
/* 배열 기초 */
#include <stdio.h>
int main() {
  int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

  printf("Array 11 번째 원소? : %d \n ", arr[10]);
  return 0;
}
```

```
Array 11 번째 원소? : 541784832 
```

도대체 무슨 값이 나온 것일까요? (경우에 따라서 아예 오류를 내고 종로될 수 도 있습니다.)

![img](https://modoocode.com/img/c/11.1.1.png)

위 그림은 `arr`이 메모리 상에서 어떠한 형태로 배치되어 있는지 보여주는 그림입니다.

C의 배열은 단순히 해당 타입의 변수들의 나열이라 생각하면 됩니다. 따라서 배열에는 배열에 크기에 관한 그 어떠한 정보가 없습니다. 다시말해 우리가 `arr[3]` 이렇게 한다면 C 언어 상에서 그냥 **아 배열의 처음 위치로 부터 4 번째 원소구나** 라고 생각하는 것이죠.

럼 `arr` 배열의 끝 부분을 살펴봅시다. 위 처럼 메모리 상에 `arr[9]` 가 맨 마지막에 있을 것이고, 그리고 그 뒤 메모리 부분에는 다른 변수들의 데이터가 들어 있겠죠.

하지만 `arr[10]` 를 사용한다면 프로그램 입장에서는 마치 `arr[9]` 뒤에 `arr[10]` 이 있는 것 처럼 생각해서 해당 영역의 값을 보여주게 됩니다. 만일 해당 부분의 메모리 영역이 접근 불가능한 영역이라면, 프로그램은 오류를 내고 종료될 것입니다. 아니라면 해당 부분을 사용하고 있는 데이터의 값이 보여지겠죠.

더 안좋은 일은 해당 부분의 값을 다른 값으로 덮어 씌울 경우 입니다. 예를 들어서 해당 영역을 `b` 라는 변수가 사용하고 있었다고 해봅시다. 그러면 `arr[10] = 3` 을 한다면 마치 `b = 3` 을 한 듯한 효과를 내겠죠? 이는 정말 찾기 힘든 어려운 버그로 이어질 가능성이 높습니다. 따라서 배열을 사용할 때에는 반드시 **우리가 참조하는 원소의 위치가 배열의 크기 보다 작은지 확인** 해야 합니다.

### 소수 찾는 프로그램

이번에는 배열을 활용한 프로그램을 하나 더 살펴 보겠습니다. 이번 프로그램은 '배열' 을 활용한 소수 찾는 프로그램 입니다. **소수(prime number)**는 1 과 자신을 제외한 약수가 하나도 없는 수를 일컫습니다.

예를 들어, 2 와 3 은 소수 이지만 4 는 2 가 약수 이므로 소수가 아니지요. 또한 1 도 소수가 아닙니다. 아무튼, 소수를 찾는데 배열을 활용한다는 것은 이전에 찾은 소수들을 배열에 저장하여, 어떠한 수가 소수인지 판별하기 위해 그 수 이하의 소수들로 나누어 본다는 뜻입니다.

만일, 그 수 이하의 모든 소수들로 나누었는데 나누어 떨어지는 것이 없다면 그 수는 소수가 됩니다.또한, 짝수 소수는 2 가 유일하므로 홀수들에 대해서만 계산하도록 합니다 . 또한, 짝수 소수는 2 가 유일하므로 홀수들에 대해서만 계산하도록 합니다.

```c
/* 소수 프로그램 */
#include <stdio.h>
int main() {
  /* 우리가 소수인지 판별하고 있는 수 */
  int guess = 5; /* 소수의 배열 */
  int prime[1000]; /*    현재까지 찾은 (소수의 개수 - 1)    아래 두 개의 소수를
                      미리 찾았으므로    초기값은 1 이 된다.    */
  int index = 1; /* for 문 변수 */
  int i;         /* 소수인지 판별위해 쓰이는 변수*/
  int ok;        /* 처음 두 소수는 특별한 경우로 친다 */
  prime[0] = 2;
  prime[1] = 3;
  for (;;) {
    ok = 0;
    for (i = 0; i <= index; i++) {
      if (guess % prime[i] != 0) {
        ok++;
      } else {
        break;
      }
    }
    if (ok == (index + 1)) {
      index++;
      prime[index] = guess;
      printf("소수 : %d \n", prime[index]);
      if (index == 999) break;
    }
    guess += 2;
  }
  return 0;
```

```c
for (i = 0; i <= index; i++) {
  if (guess % prime[i] != 0) {
    ok++;
  } else {
    break;
  }
}
```

위 부분은 `guess` 이하의 모든 소수들로 나누어 보고 있는 작업 입니다. `index` 는 `(배열에 저장된 소수의 개수 - 1)` 인데 `prime[i]` 로 접근하고 있으므로 배열의 모든 소수들로 나누어 보게 됩니다.

만일 `guess` 가 `prime[i]` 로 나누어 떨어지지 않는다면 `ok` 를 1 증가 시킵니다. 그리고 나누어 떨어진다면 소수가 아니므로 바로 `break` 되서 루프를 빠져 나가게 됩니다. 만일 `ok` 가 `prime` 배열에 저장된 소수의 개수, 즉 `(index + 1)`과 같다면 자기 자신 미만의 모든 소수들로도 안 나누어 떨어진다는 뜻이 되므로 소수가 됩니다.

이 때, 주의해야 할 점은 한 개의 수를 검사할 때 마다 `ok` 가 0 으로 리셋되어야 합니다. 그렇지 않다면 정확한 결과를 얻을 수 없겠죠?

```cpp
if (ok == (index + 1)) {
  index++;
  prime[index] = guess;
  printf("소수 : %d \n", prime[index]);
  if (index == 999) break;
}
```