# 함수의 인자로 이중 포인터 받기

지난번 내용은 잘 기억하고 있는지요? 다시 한 번 요약해 보자면, "어떠한 함수가 특정한 타입의 변수/배열의 값을 바꾸려면 함수의 인자는 반드시 타입을 가리키는 포인터 형을 이용해야 한다!" 였습니다.사실, 이 문장이 이해가 잘 되지 않았던 분들이 있으리라 생각됩니다. 하지만, 이번 강좌를 보고 난다면 이 문장의 의미를 정확하게 파악할 수 있을 것입니다.

```cpp
/* 눈 돌아가는 예제. 포인터가 가리키는 변수를 서로 바꾼다.  */
#include <stdio.h>

int pswap(int **pa, int **pb);
int main() {
  int a, b;
  int *pa, *pb;

  pa = &a;
  pb = &b;

  printf("pa 가 가리키는 변수의 주소값 : %p \n", pa);
  printf("pa 의 주소값 : %p \n \n", &pa);
  printf("pb 가 가리키는 변수의 주소값 : %p \n", pb);
  printf("pb 의 주소값 : %p \n", &pb);

  printf(" ------------- 호출 -------------- \n");
  pswap(&pa, &pb);
  printf(" ------------- 호출끝 -------------- \n");

  printf("pa 가 가리키는 변수의 주소값 : %p \n", pa);
  printf("pa 의 주소값 : %p \n \n", &pa);
  printf("pb 가 가리키는 변수의 주소값 : %p \n", pb);
  printf("pb 의 주소값 : %p \n", &pb);
  return 0;
}
int pswap(int **ppa, int **ppb) {
  int *temp = *ppa;

  printf("ppa 가 가리키는 변수의 주소값 : %p \n", ppa);
  printf("ppb 가 가리키는 변수의 주소값 : %p \n", ppb);

  *ppa = *ppb;
  *ppb = temp;

  return 0;
}
```

성공적으로 컴파일 하면

실행 결과

```
pa 가 가리키는 변수의 주소값 : 0x7ffc5ffd7520 
pa 의 주소값 : 0x7ffc5ffd7528 
 
pb 가 가리키는 변수의 주소값 : 0x7ffc5ffd7524 
pb 의 주소값 : 0x7ffc5ffd7530 
 ------------- 호출 -------------- 
ppa 가 가리키는 변수의 주소값 : 0x7ffc5ffd7528 
ppb 가 가리키는 변수의 주소값 : 0x7ffc5ffd7530 
 ------------- 호출끝 -------------- 
pa 가 가리키는 변수의 주소값 : 0x7ffc5ffd7524 
pa 의 주소값 : 0x7ffc5ffd7528 
 
pb 가 가리키는 변수의 주소값 : 0x7ffc5ffd7520 
pb 의 주소값 : 0x7ffc5ffd7530
```

여러분의 출력결과는 위 사진과 다를 수 있습니다.

`pa` 가 가리키는 변수의 주소값은 (즉, `pa` 의 값이지요) `0x7520` 였습니다. (편의상 앞에 공통된 `0x7ffc5ffd` 는 생략합시다) `pb` 가 가리키는 변수의 주소값은 `0x7524` 이였습니다. 그런데 말이죠. `pswap` 함수를 호출하고 나니, `pa` 가 가리키는 변수의 주소값은 `0x7524` 이 되고, `pb` 가 가리키는 변수의 주소값은 `0x7520` 가 되었습니다. 즉, 두 포인터가 가리키는 변수가 서로 뒤바뀐 것이지요.

이 때, 우리는 이와 같은 함수를 만들기 위해서, 인자를 어떤 형식으로 취해야 될까요? 앞서 말했듯이, 특정한 타입의 변수의 값을 바꾸려면, 특정한 타입을 가리키는 포인터로 인자를 취해야 된다고 했습니다. 그런데, 이 예제의 경우, 특정한 타입은 `int*` 타입입니다. 그렇다면 `int*` 타입을 가리키는 포인터의 타입은? 음. 강좌를 잘 복습하였다면 `int**` 타입 이라고 말할 수 있겠지요. (잘 모르겠다면 [12-3 강, 포인터는 영희이다!](https://modoocode.com/25)를 보세요)

따라서, 우리는 위 이야기를 토대로 아래와 같이 함수를 정의하였습니다.

```cpp
int pswap(int **ppa, int **ppb)
```

상당히, 잘한 것이지요. 이제, 함수의 몸체를 봐봅시다.

```cpp
int pswap(int **ppa, int **ppb) {
  int *temp = *ppa;

  printf("ppa 가 가리키는 변수의 주소값 : %p \n", ppa);
  printf("ppb 가 가리키는 변수의 주소값 : %p \n", ppb);

  *ppa = *ppb;//주소값의 교환
  *ppb = temp;

  return 0;
}
```

일단, `int*` 형의 `temp` 변수를 만들어서 `*ppa` 의 값을 저장하고 있습니다. 그런데, `*ppa` 의 값은 무엇일까요?

만일 우리가 위 예제 처럼 `pswap` 함수를 호출하였다고 하면, `ppa` 는 `pa` 를 가리키고 있고, `ppb` 는 `pb` 를 가리키고 있겠지요. 따라서, `*ppa` 라 하면 `pa` 의 값을 이야기 합니다. 그런데, `pa` 는 `int*` 형이므로, `pa` 의 값을 보관하는 변수는 반드시 `int*` 이여야 되겠지요. 따라서, 우리는 `int*` 형의 `temp` 변수를 정의하였습니다. 그 아래의 내용은 이전에 만들어 보았던 `swap` 함수와 동일합니다.

```cpp
printf("ppa 가 가리키는 변수의 주소값 : %p \n", ppa);
printf("ppb 가 가리키는 변수의 주소값 : %p \n", ppb);
```

그렇다면 우리는 위 두개의 [printf](https://modoocode.com/35) 문장에서 어떤 결과가 출력될 지 예측 가능합니다. 위 예제에서 `ppa` 가 `pa` 를 가리키고 있으므로 `ppa` 의 값을 출력하면 `pa` 의 주소값이 나오고, `ppb` 도 마찬가지로 나오겠죠. 위 출력결과에서 실제로 같다는 것을 확인할 수 있습니다. 어때요. `pswap` 함수가 이해가 되나요?

위 과정을 그림으로 표현하면 아래와 같습니다.



![img](https://modoocode.com/img/146B111F4B2CB12B40F6C1.webp)

그렇다면, 이번에는 이차원 배열을 인자로 받는 함수에 대해서 생각해 보도록 합시다.

```cpp
/* 2 차원 배열의 각 원소를 1 씩 증가시키는 함수 */
#include <stdio.h>
/* 열의 개수가 2 개인 이차원 배열과, 총 행의 수를 인자로 받는다. */
int add1_element(int (*arr)[2], int row);
int main() {
  int arr[3][2];
  int i, j;

  for (i = 0; i < 3; i++) {
    for (j = 0; j < 2; j++) {
      scanf("%d", &arr[i][j]);
    }
  }

  add1_element(arr, 3);

  for (i = 0; i < 3; i++) {
    for (j = 0; j < 2; j++) {
      printf("arr[%d][%d] : %d \n", i, j, arr[i][j]);
    }
  }
  return 0;
}
int add1_element(int (*arr)[2], int row) {
  int i, j;
  for (i = 0; i < row; i++) {
    for (j = 0; j < 2; j++) {
      arr[i][j]++;
    }
  }

  return 0;
}
```

성공적으로 컴파일 하였다면

실행 결과

```
1 2 3 4 5 6
arr[0][0] : 2 
arr[0][1] : 3 
arr[1][0] : 4 
arr[1][1] : 5 
arr[2][0] : 6 
arr[2][1] : 7 
```

역시 잘 실행되는군요. 일단, 함수의 정의부분 부터 살펴봅시다.

```cpp
int add1_element(int (*arr)[2], int row) { //2차원 배열의 값을 변경하고 싶으니 포인터로 적용
  int i, j;
  for (i = 0; i < row; i++) {
    for (j = 0; j < 2; j++) {
      arr[i][j]++;
    }
  }

  return 0;
}
```

이 함수는 인자를 두 개 받고 있는데 하나는 열의 개수가 2 개인 이차원 배열을 가리키는 포인터 이고, 하나는 함수의 행의 수를 받는 인자입니다.

```cpp
for (i = 0; i < row; i++) {
  for (j = 0; j < 2; j++) {
    arr[i][j]++;
  }
}
```

우리는 `row` 를 통해 이 이차원배열의 행의 개수를 알 수 있고, 열의 개수는 이미 알고 있으므로 (배열 포인터에서) 각 원소를 1 씩 증가시키는 작업을 시행할 수 있게됩니다. 위와 같이 말이죠. 우리는 포인터를 잘 배워서 헷갈릴 문제는 없지만 많은 사람들에게 다음과 같이 인자를 받는것이 어렵게 느껴집니다.

```cpp
int add1_element(int (*arr)[2], int row)
```

그래서, 오직 함수의 인자의 경우에서만 위 형태의 인자를 다음과 같이도 표현할 수 있습니다.

```cpp
int add1_element(int arr[][2], int row)
```

이는 오직 함수의 인자에서만 적용되는 것입니다. 만일

```cpp
int parr[][3] = arr;
```