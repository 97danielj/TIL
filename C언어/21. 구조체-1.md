# 구조체 - 1

구조체: 타입이 다른 데이터를 하나로 묶는 방법

![img](https://blog.kakaocdn.net/dn/ttyaN/btqBSOEdYfT/OO1OcA2ahurO9yH2zSldDK/img.png)

```c
#include <stdio.h>

struct Human{
    int age;
    int height;
    int weight;
    
};

int main(){
    select Human Psi;
    Psi.age = 99;
    Psi.height = 185;
    Psi.weight = 80;
    printf("Psi 에 대한 정보 \n");
    printf("나이   : %d \n", Psi.age);
    printf("키     : %d \n", Psi.height);
    printf("몸무게 : %d \n", Psi.weight);
    return 0;
  
    
}
```

아마 여러분은 위 소스 코드에서 여러가지 새로운 것들을 보실 수 있으셨을 겁니다. 아마 이 강좌가 끝날 즈음에는 위 사실들을 자유롭게 다룰 수 있게 되니 크게 걱정 안하셔도 됩니다. 일단 구조체를 정의한 부분 부터 살펴 봅시다. 직관적으로 아래의 부분과 같다는 사실을 알 수 있습니다.

```cpp
struct Human {
  int age;    /* 나이 */
  int height; /* 키 */
  int weight; /* 몸무게 */
};            /* ; 붙이는 것 주의하세요 */
```

앞서 말했듯이 구조체는 "**각 원소의 타입이 제각각인 배열**" 이라고 말했습니다. 이 때문에 배열에서는 배열의 타입만으로 모든 원소의 타입을 알 수 있었지만 (예를 들어 `int array[100]` 이면 [array](https://modoocode.com/314) 의 모든 원소의 타입은 `int` 형 이다)

구조체는 그렇지 않습니다. 따라서 구조체는 정의할 때 모든 원소의 타입을 명시해 주어야 합니다. 위와 같이 말이죠. 이 `Human` 이라는 이름의 구조체는 3 개의 멤버를 가지고 있는데 (보통 구조체 에서는 원소 보다는 **멤버(member)** 라고 부릅니다) 각각의 멤버는 `int age, int height, int weight` 로 3 개가 있습니다.

구조체의 일반적인 정의는 아래와 같습니다.

구조체의 일반적인 정의는 아래와 같습니다.

```cpp
struct 구조체이름 {
  멤버들..예를 들면 char str[10];
  int i;
}; /* 마지막에 꼭 ; 를 붙인다. */
```

다음은 `main` 함수내부를 살펴 볼 것입니다.

```cpp
struct Human Psi;
```

와 같이 `Human` 이라는 구조체의 구조체 변수 Psi 를 정의하였습니다. 여기서 놀라운 점은 `struct Human` 이라는 것이 우리가 마치 `int` 형 변수를 정의할 때 `int` 를 쓰는 것과 같이 사용되었다는 것입니다. 아무튼 이처럼 Psi 를 정의하고 나면,`Psi` 의 타입은 `struct Human`, 즉 `Human 구조체` 가 됩니다. `int a` 했을 때 `a` 의 타입이 `int` 인 것처럼 말이지요.

그렇다면 배열에서 `[]` 를 이용해서 원소에 접근하듯이, 구조체에서도 멤버에 접근할 방법이 있어야 겠죠? C 언어에서는 `.` 을 이용하여 원소에 접근할 수 있습니다. 예를 들어서, Psi 의 `height` 멤버에 접근하려면 `Psi.height` 라고 하면 됩니다. 이는 마치 배열에서 `arr[3]` 과 같이 원소에 접근하는 것과 동일한 것입니다. 다만 구조체는 `.` 을 이용하고, 멤버가 무엇인지 특별히 명시해주어야 하는 것만 빼고요.

> 구조체의 정의에서는 변수를 초기화 할 수 없기 때문입니다. 그냥, 받아 들여주세요. 구조체 정의 내부에서는 변수를 초기화 할 수 없다고 말이죠. 특히, 위와 같이 실수를 할 경우 찾기도 잘 어렵고 오류들도 엉뚱한 것들만 나오기 때문에 위와 같은 실수를 조심하는 것이 아주 중요합니다.

## 구조체 배열

```cpp
struct Books book_list[3];
```

일단 위 문장을 보았을 때 어떤 분들은 이해가 잘 되지만 어떤 분들은 이해가 안될 수 도 있을 것이니 다시 한 번 설명하겠습니다. 이전에도 말했듯이 `int arr[3]` 에서 `int` 가 하나의 타입이듯이, `struct Books` 가 하나의 타입으로 생각하면 됩니다. 그런데, `int arr[3]` 을 하면 `arr` 에 `int` 형 원소가 3 개 만들어지듯이, `book_list` 배열에는 `struct Books` 형의 변수가 3 개 만들어지는 것이지요.



## 구조체 포인

```cpp
/* 구조체 포인터 */
#include <stdio.h>
struct test {
  int a, b;
};
int main() {
  struct test st;
  struct test *ptr;

  ptr = &st;

  (*ptr).a = 1;
  (*ptr).b = 2;

  printf("st 의 a 멤버 : %d \n", st.a);
  printf("st 의 b 멤버 : %d \n", st.b);

  return 0;
}
```

먼저 구조체 포인터에 대해 이야기 하기 전에 확실히 짚고 넘어가야 할 것이 있습니다. 여태까지 누누히 이야기 하였지만 `struct test` 역시 하나의 형 (타입) 이라는 것입니다. 위의 예제들의 `struct Human` 이나 `struct Book` 역시 하나의 타입이였지요.

즉, 구조체는 한 개의 타입을 창조하는 것과 마찬가지라는 것입니다. 마치 `int` 나 `char` 처럼 말이지요. 그런데 이러한 타입들을 가리킬 때 우리가 포인터를 어떻게 사용했나요? 바로, `int *` 나 `char *` 로 사용했습니다. 구조체도 마찬가지 입니다.

```cpp
struct test st;
struct test *ptr;
```

위의 두 번째 문장과 같이 `struct test *ptr,` 즉 "struct [test](https://modoocode.com/test) 형을 가리키는 포인터 ptr" 을 정의한 것이지요. 여기서 주의해야 할 점은 `ptr` 은 절대로 **구조체가 아니라는 것**입니다. `ptr` 역시 다른 모든 포인터 처럼 8 바이트의 공간을 차지하는 것입니다. (물론 컴퓨터 마다 다를 수 있지만 아마 여러분이 사용하는 컴퓨터는 십중 팔구일 것입니다)

리고 위와 같이 `ptr` 에 [str](https://modoocode.com/str) 의 주소값을 집어 넣습니다. 그런데 눈치가 조금 빠르신 분들은 다음과 같이 질문할 수 있습니다.

"아까 구조체는 단순히 원소의 크기가 제각각인 배열이라면서요? 그러면 구조체도 배열처럼 변수의 이름이 그 주소값이 되어야 하는 것 아닌가요? 다시 말해 우리가 `int arr[100];` 을 정의했다면 이를 가리키는 포인터를 정의할 때 `int *ptr = arr` 이라고 하지 `int *ptr = &arr` 이라 하지 않잖아요?"

상당히 좋은 질문 입니다. 하지만 조금 아래에 보면 구조체 변수의 이름은 역할이 살짝 다르다는 것을 알게 됩니다. 그냥 보통 변수 처럼, (그래서 구조체 변수라 부르지, 구조체 '배열' 이라고 부르지 않잖아요) `&` 를 붙여 구조체가 정의된 메모리의 주소값을 얻어온다고 생각해주세요.

이제 `ptr` 은 구조체 `st` 를 가리키는 포인터가 됩니다.

```cpp
(*ptr).a = 1;
(*ptr).b = 2;
```

그럼 `ptr` 이 가리키는 구조체의 멤버의 값을 변경하는 부분을 살펴 봅시다. 일단 여러분은 `(*ptr)` 이라는 부분이 `st` 라는 것과 동일하다는 사실을 알 수 있습니다. 왜냐하면 `ptr` 이 `st` 를 가리키고 있기 때문이죠. 따라서 `(*ptr).a = 1` 은 `st.a = 1` 과 완전히 `100%` 동일한 문장임을 알 수 있습니다. 그 아랫 줄도 마찬가지이죠. `(*ptr).b = 2` 도 `st.b = 2` 와 정확히 일치하는 문장입니다. 따라서 아래 [printf](https://modoocode.com/35) 문에서 `st.a` 의 값은 `1, st.b` 의 값은 2 가 출력된 것입니다.

그런데 말이죠. 굳이 괄호를 쳐 주어야 하나요? 그냥 `*ptr.a = 1` 이라 하면 무엇이 문제이길래 그런 것인가요?

그런데 말이죠. 굳이 괄호를 쳐 주어야 하나요? 그냥 `*ptr.a = 1` 이라 하면 무엇이 문제이길래 그런 것인가요?

```
    (*ptr).a = 1; 을
    *ptr.a = 1; 로 바꿔서 컴파일 해봅시다.
```

그렇다면 아래의 오류들을 만나실 수 있을 것입니다.

컴파일 오류

```
error C2231: '.a' : 왼쪽 피연산자가 'struct'을(를) 가리킵니다. '->'를 사용하십시오.
error C2100: 간접 참조가 잘못되었습니다.
```

도대체 왜 발생한 것일까요? 이에 대해 답하기 전에 연산자 우선 순위 표를 먼저 살펴봅시다.



![img](https://modoocode.com/img/183F47204B7806317A2E79.webp)



가장 맨 위를 보면 `.` 이라고 되있는 것을 볼 수 있습니다. 찾았나요? 여기서 `.` 은 구조체의 멤버를 지칭할 때 사용하는 `.` 을 의미하는 것입니다. `(*ptr).a` 에서 사용된 `.` 을 말하지요. 그 바로 아래 행을 보면 `*(포인터)` 라고 써있는 것이 있습니다. `(*ptr).a` 에서의 `*` 를 말하는 것이지요. 여기서 주목해야 할 점은 `.` 이 `*` 보다 우선순위가 높다는 것입니다.

따라서, `*ptr.a` 를 사용하게 되면 `ptr.a` 를 먼저 실행한 후, 그 값에 `*` 를 한 것에 2 가 들어가게 됩니다. 즉 `*ptr.a` 는 `*(ptr.a)` 와 동일한 문장인 것이지요. 그런데 위에서도 말했지만 `ptr` 은 단순히 포인터에 불과합니다. `ptr` 은 절대로 구조체가 아니라는 것이지요. 그런데 구조체가 아닌 것의 있지도 않는 `a` 라는 멤버에 접근하라니 컴파일 시에 오류가 발생하는 것입니다.

```cpp
/* 구조체 포인터 */
#include <stdio.h>
struct test {
  int a, b;
};
int main() {
  struct test st;
  struct test *ptr;
  ptr = &st;
  ptr->a = 1;
  ptr->b = 2;
  printf("st 의 a 멤버 : %d \n", st.a);
  printf("st 의 b 멤버 : %d \n", st.b);
  return 0;
}
```