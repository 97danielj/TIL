# 포인터 - 1

---

우리는 앞으로 편의를 위해, 메모리의 특정한 공간을 '방' 이라고 하겠습니다. 각 방에는 데이터들이 들어가게 되는 것 입니다.

한 방의 크기는 보통 1 바이트 라고 정의됩니다. 우리가 만약 4 바이트 짜리 `int` 형 변수를 정의한다면메모리 상의 4 칸을 차지하게 됩니다.

프로그램 작동 시 컴퓨터는 여러 방들에 있는 데이터를 필요로 하게 됩니다. 따라서, 어떤 방에서 데이터를 가져올 지 구분하기 위해 각 방에 교유의 주소(address)를 붙여 주었습니다.

예를 들어 우리가 아래와 같은 `int` 변수 `a` 를 정의하였다면 특정	한 방에 아래 그림 처럼 변수 `a` 가 정의됩니다.

```cpp
int a = 123;  // 메모리 4 칸을 차지하게 한다.
```

![메모리에 123 이란 수가 있고 이 수는 메모리에 0x152839 (앞에 0x 는 이 수가 16 진수로 표시되었다는 것을 의미해요 에 위치](https://modoocode.com/img/1369D1164AF9739C0ED550.webp)



이 때, `0x152839` 는 제가 아무렇게나 정한 이 방의 시작 주소 입니다. 참고로, `0x` 가 뭐냐고 물어보는 사람들이 있을 텐데, 이전 강좌에서도 이야기 하였지만 16 진수라고 표시한 것 입니다. 즉, 16 진수로 `152839` (10 진수로 1386553) 라는 위치에서 부터 4 바이트의 공간을 차지하며 123 이라는 값이 저장되어 있게 하라는 뜻이지요.

그렇다면 아래와 같은 문장은 어떻게 수행 될까요?

```cpp
a = 10;
```

사실 컴파일러는 위 문장을 아래와 같이 바꿔주게 됩니다.

메모리 `0x152839` 위치에서 부터 4 바이트의 공간에 있는 데이터를 10 으로 바꾸어라!

결과적으로, 컴퓨터 내부에서는 올바르게 수행되겠지요.

32 비트에서 작동되는 컴퓨터들은 모두 주소값의 크기가 32 비트 (즉, 4 바이트.. 까먹었다면 2 - 3 강 참조) 로 나타내집니다. 즉 주소값이 `0x00000000 ~ 0xFFFFFFFF` 까지의 값을 가진다는 것이지요.

32비트로 사용할 수 있는 주소값의 가지수는 2의 32 바이트, 즉 RAM은 최대 4GB까지 밖에 사용할 수 없다는 사실을 알 수 있습니다. 맞습니다. 이때문에 32비트 운영체제에서는 RAM의 최대 크기기 4GB으로 제한되지요. (즉, 돈을 많이 들여서 RAM을 10GB로 만들어도 컴퓨터는 4GB까지 밖에 인식하지 못합니다.)

포인터는 우리가 앞에서 보았던 `int` 나 `char` 변수들과 다른 것이 전혀 아닙니다. 포인터도 '변수' 입니다. `int` 형 변수가 정수 데이터, `float` 형 변수가 실수 데이터를 보관했던 것 처럼, 포인터도 특정한 데이터를 보관하는 '변수' 입니다. 그렇다면 포인터는 무엇을 보관하고 있을 까요?

바로, 특정한 데이터가 저장된 주소값을 보관하는 변수입니다. 여기서 강조할 부분은 '주소값' 이라는 것 이지요. 여기서 그냥 머리에 박아 넣어 버립시다. 이전에 다른 책들에서 배운 내용을 싹 다 잊어 버리고 그냥 망치로 때려 넣듯이 박아버려요. 포인터에는 특정한 데이터가 저장된 주소값을 보관하는 변수 라고 말이지요. 크게 외치세요. '주소값!!!!!'

## 포인터

다시 한 번 정리하자면

```
포인터 : 메모리 상에 위치한 특정한 데이터의 (시작)주소값을 보관하는 변수
```

우리가 변수를 정의할 때 `int` 나 `char` 처럼 여러가지 **형(type)** 들이 있었습니다. 그런데 놀랍게도 포인터에서도 형이 있습니다.

이 말은 포인터가 메모리 상의 `int` 형 데이타의 주소값을 저장하는 포인터와, `char` 형 데이터의 주소값을 저장하는 포인터가 서로 다르다는 말입니다. 응?? 여러분의 머리속에는 아래와 같은 생각이 번개 처럼 스쳐 지나갈 것입니다.

> 아까 포인터는 주소값을 저장하는 거래며. 근데 우리가 쓰는 컴퓨터에선 주소값이 무조건 32 비트, 즉 4 바이트래며! 그러면 포인터의 크기는 다 똑같은것 아냐? 근데 왜 포인터가 형(type)을 가지는 건데?!

휴우우. 진정좀 하시고. 여러분 말이 백번 맞습니다 - 단, 현재 까지 배운 내용을 가지고 생각하자면 말이지요. 포인터를 아주 조금만 배우면 왜 포인터에 형(type) 이 필요한지 알게 될 것입니다.

C언어에서 포인터는 다음과 같이 정의 할 수 있습니다.

```c
(포인터에 주소값이 저장되는 데이터의 형) *(포인터 이름);
```

혹은 아래와 같이 정의

```c
(포인터에 주소값이 저장되는 데이터의 형)* (포인터 이름);
```

예를 들어 `p`라는 포인터가 `int`데이터를 가리키고 싶다 한다면

```c
int* p;
int *p;
```

라 하면 됩니다. 즉, 위 포인터`p`는 `int`형 데이터의 주소값을 저장하는 변수가 되는 것입니다.

### &연산자

포인터를 정의하였으면 값을 집어 넣어야 하는데 이 경우 `&`연산자를 사용하면 됩니다.

```c
a & b; // (비트 연산자), 다항 연산자
&a; // 단항 연산자여서 괜찮음
```

```c
/* &연산자 */
#include <stdio.h>
int main(){
    int a = 2;
	printf("%p, \n", &a);
    return 0;
}
```

성공적으로 컴파일 했다면

실행 결과

```
0x7fff80505b64 
```

와 같이 나옵니다. 참고로, 여러분의 컴퓨터에 따라 결과가 다르게 나올 수 도 있습니다. 사실, 저와 정말 인연 이상의 무언가가 있지 않는 이상 전혀 다르게 나올 것 입니다. 더 놀라운 것은 실행할 때 마다 결과가 달라질 것입니다.

```cpp
printf("%x \n", &a);
```

위 문장에서 `&a` 의 값을 16 진수 형태 (`%p`) 로 출력하라고 명령하였습니다. 근데요. 눈치가 있는 사람이라면 금방 알겠지만 위에서 출력된 결과는 8 바이트 (16 진수로 16 자리)가 아닙니다! (여러분의 컴퓨터는 다를 수 있습니다.) 제가 지금 64 비트 운영체제를 사용하고 있는데도 말이지요!

그렇다면 뭐가 문제인가요? 사실, 문제는 없습니다. 단순히 앞의 0 이 잘린 것 이지요. 주소값은 언제나 8 바이트 크기, 즉 16 진수로 16 자리 인데 앞에 0 이 잘려서 출력이 안된 것일 뿐입니다. 따라서 변수 `a` 의 주소는 아마도 `0x00007ffe37d03104` 가 될 것입니다.

```cpp
/* 포인터의 시작 */
#include <stdio.h>
int main() {
  int *p;
  int a;

  p = &a;

  printf("포인터 p 에 들어 있는 값 : %p \n", p);
  printf("int 변수 a 가 저장된 주소 : %p \n", &a);

  return 0;
}
```

실행해 보면 많은 이들이 예상했던 것 처럼....

실행 결과

```
포인터 p 에 들어 있는 값 : 0x7fff894c8b3c 
int 변수 a 가 저장된 주소 : 0x7fff894c8b3c 
```

똑같이 나옵니다. 어찌 보면 당연한 일입니다.

```cpp
p = &a;
```

에서 포인터 `p` 에 `a` 의 주소를 대입하였기 때문이죠. 참고로, 한 번 정의된 변수의 주소값은 바뀌지 않습니다. 따라서 아래 [printf](https://modoocode.com/35) 에서 포인터 `p` 에 저장된 값과 변수 `a` 의 주소값이 동일하게 나오게 됩니다. 어때요. 쉽죠?

### * 연산자

현재 까지 우리가 배운 바로는 **포인터는 특정한 데이터의 주소값을 보관한다. 이 때 포인터는 주소값을 보관하는 데이터의 형에 `\*` 를 붙임으로써 정의되고, `&` 연산자로 특정한 데이터의 메모리 상의 주소값을 알아올 수 있다** 였습니다.

`&` 연산자가 어떠한 데이터의 주소값을 얻어내는 연산자라면 거꾸로 주소값에서 해당 주소값에 대응되는 데이터를 가져오는 연산자가 필요하겠지요? 이 역할은 바로 `*` 연산자가 수행합니다!

`&` 연산자가 어떠한 데이터의 주소값을 얻어내는 연산자라면 거꾸로 주소값에서 해당 주소값에 대응되는 데이터를 가져오는 연산자가 필요하겠지요? 이 역할은 바로 `*` 연산자가 수행합니다!

> *p는 p에 저장된 주소값이 가리키는 데이터

자. 그럼 **포인터** 라는 말 자체의 의미를 생각해 봅시다. `int` 변수 `a` 와 포인터 `p` 의 메모리 상의 모습을 그리면 아래와 같습니다.



![포인터 p 도, a 도 메모리 상에 각각 존재합니다만, 그 위치에는 a 의 경우 3 이 있지만 p 의 경우 a 의 주소값이 있습니다.](https://modoocode.com/img/1618DD264AFA7A915E2A59.webp)



참고로 주소값은 제가 임의로 정한 것 입니다.

포인터 `p` 에 어떤 변수 `a` 의 주소값이 저장되어 있다면 **포인터 `p` 는 변수 `a` 를 가리킨다** 라고 말합니다. 포인터 또한 엄연한 변수 이기 때문에 특정한 메모리 공간을 차지합니다. 따라서 위 그림과 같이 포인터도 자기 자신만의 주소를 가지고 있습니다.

자. 그럼 **포인터** 라는 말 자체의 의미를 생각해 봅시다. `int` 변수 `a` 와 포인터 `p` 의 메모리 상의 모습을 그리면 아래와 같습니다.

![포인터 p 도, a 도 메모리 상에 각각 존재합니다만, 그 위치에는 a 의 경우 3 이 있지만 p 의 경우 a 의 주소값이 있습니다.](https://modoocode.com/img/1618DD264AFA7A915E2A59.webp)

참고로 주소값은 제가 임의로 정한 것 입니다.

포인터 `p` 에 어떤 변수 `a` 의 주소값이 저장되어 있다면 **포인터 `p` 는 변수 `a` 를 가리킨다** 라고 말합니다. 포인터 또한 엄연한 변수 이기 때문에 특정한 메모리 공간을 차지합니다. 따라서 위 그림과 같이 포인터도 자기 자신만의 주소를 가지고 있습니다.

### 포인터에는 왜 타입이 있을까

여기 까지 왔다면 아마 다음과 같은 의문을 가질 수 있을 것입니다.

> 포인터가 주소값만 보관하는데 왜 굳이 타입이 필요할까? 어차피 주소값은 32 비트 시스템에서 항상 4 바이트이고, 64 비트 시스템에서는 8 바이트 인데 그냥 `pointer` 라는 타입을 만들어버리면 안될까?

아주 좋은 질문 입니다. `pointer` 라는 타입이 있다고 생각해고 아래의 코드를 살펴봅시다.

```c
int a;
pointer *p;
p = &a;
*p = 4;
```

포인터 `p` 에는 명백히 변수 `a` 의 주소값이 들어 있습니다. 여기서 문제는 `a` 가 메모리에서 차지하는 모든 주소들의 위치가 들어 있는 것이 아니라 **시작 주소** 만 들어가 있다는 점입니다.

따라서, `*p` 라고 했을 때 컴퓨터는 메모리에서 얼마만큼을 읽어들어야 할지 알 길이 없습니다.

한편

```c
int a;
int *p;
p = &a;
*p = 4;
```

고 한다면 어떨 까요? 컴퓨터는 포인터 `p` 가 `int *` 라는 사실을 보고 **이 포인터는 `int` 데이터를 가리키는 구나!** 라고 알게 되어 시작 주소로 부터 정확히 4 바이트를 읽어 들어 값을 바꾸게 됩니다.