# 넘파이
## 1. 데이터

* 데이터
    * 피처의 개념
      * 트것이나 특징이라는 의미
      * 모델을 구성하는 데 데이터가 가장 큰 영향을 준다.
      * 모델은 함수 형태로 표현
    * 데이터 테이블 : 데이터를 테이블로 표현한 것
    * 데이터 인스턴스 : 하나의 의미를 가지는 데이터 모음 / 튜플  / 엑셀에서 한 줄 한 줄
    * 데이터의 분류 : 연속형 데이터와 이산형 데이터
      * 연속형 데이터와 이산형 데이터의 가장 큰 차이점은 그 숫자의 의미가 스케일이 있는가.
      * 연속형 데이터 : 값이 끊어지지않고 계속 연결되는 종류의 데이터로, 실수와 관련된 값
        * 온도, 자동차의 속도
        * 평균, 분산 등 통계적 기법 적용 가능
        * 숫자형 데이터, 명목형 데이터, 서수형 데이터
      * 이산형 데이터 : 연속적 값이 아니라 분리해서 표현하는 데이터로, 일종의 라벨로 구분 가능
        * 우편번호, 성별
        * 텍스트 형태의 값도 숫자 형태로 바꾸어 수식의 입력에 할당
    * 데이터의 형식
      * 데이터를 저장하기 위해서는 데이터 테이블 형태로 저장될 수 있는 타입을 사용한다.
      * 기본 int : int32
      * 기본 float : float64

## 2.넘파이

- 넘파이의 개념
  - 파이썬의 고성능 과학 계산용 라이브러리
  - 벡터나 행렬 같은 선형대수의 표현법을 코드로 처리
- 넘파이 특징
  - __정적 할당의 구성방식으로 사용하기 위하여 만들어짐__
  - 데이터가 메모리 직접 로딩되어있다. -> 배열의 데이터타입이 동일해야 인덱싱이 가능하다.
  - 행렬 연산 특화
  - 일반 list에비해 빠르고, 메모리를 효율적으로 사용
  - 연산을 병렬로 처리
- 넘파이 배열: 넘파이에서 텐서 데이터를 다루는 객체
- 텐서 : 선형대수의 데이터 배열

| rank |      이름      |              내용              |
| :--: | :------------: | :----------------------------: |
|  0   |     스칼라     |        원소1개 / s=777         |
|  1   |      벡터      |          1차원 array           |
|  2   | 매트릭스(행렬) |          2차원 array           |
|  3   |   3차원 텐서   |   3차원 array - Channel 추가   |
|  n   |   n차원 텐서   | n차원 array - 축이 n개인 array |

- 텐서의 shape
  - 각 축이 몇개의 엘리먼트들로 구성되었는지 나타내는 값이다. 
  - 2차원 메트릭스에서 shape(2,3)이면 2개의 벡터, 3개의 스칼라로 이루어진 행렬을 의미한다.
- 텐서의 dtype
  - 넘파이 배열의 데이터 타입을 반환
- 넘파이 특징을 출력하는 요소는 dtype과 shape
  - dtype은 넘파이 배열의 데이터타입을 반환
  - shape는 넘파이 배열에서 객체의 차원에 대한 구성 정보 반환
  - 최디차원 : np.ndim
  - 원소개수 : np.size


## 2. 넘파이 코드

### 1. 넘파이 생성 및 속성 코드

- np.array([1,2,3,4],float)
  - 매개변수1 : 배열 정보
  - 매개변수2 : 넘파이 배열로 표현하려는 데이터 타입
  - 배열원소 전달 시 항상 리스트 형식으로 입력

* 파이썬 리스트와 넘파이 배열의 차이점

  * 텐서 구조에 따라 배열 생성

    * 배열의 모든 구성 요소에 값이 존재해야 함

    * ```python
      test_list = [[1, 4, 5, 8], [1, 4, 5]]
      np.array(test_list, float) # ValueError
      ```

  * 동적 타이핑 지원하지 않음

    - 메모리 공간에서 인덱싱 때문

  * 데이터를 메모리에 연속적으로 나열

    * 각 값 메모리 크기가 동일
    * 검색이나 연산 속도가 리스트에 비해 훨씬 빠름

* 재배치 : reshape()
  * 단, reshape(-1)하면 일차원 벡터로 만든다.

* 인덱싱
* 슬라이싱
  * 슬라이싱은 인덱스 범위를 넘어가도 마지막 값까지 읽어 온다.
* np.identity(n)
  * 단위행렬(i행렬)을 생성
  * 매개변수 n으로 n×n 단위행렬을 생성

* np.eye(N,M,k)
  * 시작점과 행렬 크기를 지정, 단위행렬 생성
  * N은 행의 개수, M은 열의 개수를 지정
  * k는 열의 값을 기준으로 시작 인덱스
* np.diag(mix,k)
  * 행렬의 대각성분 값을 추출
  * k는 열의 값 기준

​	

### 2. 넘파이 연산함수

> 배열 내부 연산을 지원하는 함수

- 축 : 배열의 랭크가 증가할 때마다 새로운 축이 추가되어 차원이 증가

- sum함수
   - 각 요소의 합을 반환
   - sum함수를 랭크가 2이산인 배열에 적역시 축으로 연산방향을 설정
   - shape의 값이 (a,b,c) 이면 axis=0이 3차원 축, axis=1이 2차원 축, axis=1차원 축이된다. 즉 축의 값이 낮을 수록 고차원이다.

- 연결함수

- > 두 객체간의 연결을 지원하는 함수. 매개변수는 하나의 튜플만

   - np.vstack함수 : 배열을 수직으로 붙여 하나의 행렬을 생성
   - np.hstack함수 : 배열을 수평으로 붙여 하나의 행렬을 생성
   - concatenate 함수
     - 축을 고려하여 두 개의 배열을 결함
     - 스택 계열의 함수와 달리 생성될 배열과 소스가 되는 배열의 차원이 같아야 함
     - 두 벡터를 결합하고 싶다면, 해당 벡터를 일단 2차원 배열 꼴로 변환 후 행렬로 나타내야 함

* 사칙연산 함수

  * 같은 배열의 구조일 떄 요소별 연산

    * 요소별 연산 : 두 배열의 구조가 동일할 경우 같은 인덱스 요소들끼리 연산
    * 행렬방적싱적으로도 적용이 된다. (3,2)*(2,3)  배열연산
    * 배열간의 곱
      * 요소별 연산

      * 벡터의 내적(dot)
        * 두 배열 간의 곱셈
        * 두 개의 행렬에서 첫 번째 행렬의 열 크기와 두 번째 행렬의 행 크기가 동일해야 함


- 브로드캐스팅 연산(broadcasting operations) 
  - __하나의 행렬과 스칼라 값들 간의 연산이나 행렬과 벡터 간의 연산__
    - 방송국에 전파가 퍼지듯이 뒤에 있는 스칼라 값이 모든 요소에 퍼지듯이 연산
- 비교 연산
  - __연산 결과는 항상 불린형(boolean type)을 가진 배열로 추출. 반환 배열은 기존배열과 shape과 동일__ 
    - 불린인덱스에 사용
  - 브로드캐스팅 비교 연산
    - 하나의 스클라 값과 벡터 간의 비교 연산은 벡터 내의 전체 요소에 적요
  - 요소별 비교 연산
    - 두 개의 배열 간 배열의 구조가 동일한 경우
    - 같은 위치에 있는 요소들끼리 비교 연산
- all 함수
  - 배열 내부의 모든 값이 참일 경우 True
  - 하나라도 참이 아닐 경우 Flase를 반환
  - and조건을 전체 요소에 적용
- any 함수
  - 배열 내부 값 중 하나라도 참일 때는 True
  - 모두 거짓일 경우 False를  반환
  - or조건을 전체 요소에 적용
- where 함수
  – 배열이 불린형으로 이루어졌을 때 참인 값들의 인덱스를 반환

```python
x = np.array([4, 6, 7, 3, 2])
np.where(x>5) #참인 값들의 인덱스 리턴
np.where(x>5,10,20)
#참인 값들은 10으로 거짓인 값들은 20으로 대치
```

- 인덱스 반환

- ```python
  d=np.array([1,5,3,7,2,8,4])
  np.argsort(d) #배열 내 값들을 작은순서대로 인덱스 반환
  np.argmax(d) #배열 내 가장큰값의 인덱스 반환
  np.argmin(d) #배열 내 가장 작은 값의 인덱스 반환
  ```

- 불린 인덱스(boolean index)

  - 불린형 배열 : 기존 배열이 비교 연산을 통해 동일한 shape의 불린형 배열을 반환
  - 인덱스에 들어가는 배열은 불린형이여 한다.
  - 불린형 배열과 추출 대상이 되는 배열의 구조가 같아야 함
  - __인덱스자리 [행,] or [,열] 마스크를 집어넣으면, true에 해당하는 행or열만 뽑아낸다.__

  

- 팬시 인덱스(fancy index)
  - __정수형 배열의 값을 사용하여 해당 정수의 인덱스에 위치한 값을 반환__
  - __인덱스 항목에 넣을 배열은 정수로만 구성되어야 함__
  - 정수 값의 범위는 대상이 되는 배열이 가지는 인덱스의 범위
  - 기준 배열의 원소값은 추출한 배열의 차원의 인덱스 번호를 나타낸다.

​	

- 넘파이의 random클래스의 함수

|                      함수                       |             범위             |                        반환                        |
| :---------------------------------------------: | :--------------------------: | :------------------------------------------------: |
|            **np.random.rand(m,n)****            |          **[0, 1)**          |   **주어진 형태의 난수 어래이를 생성. 균등분포**   |
| **np.random.uniform(시작값, 끝값, 데이터개수)** |      **균등분포 함수**       |        **균등분포를 가지는 데이터의 배열**         |
|       **np.random.randint(m1,m2,size=)**        |          **[m,n)**           |      **[m,n)의 범위에서 임의의 정수를 생성**       |
|            **np.random.randn(m,n)**             |   **표준정규분포 N(1, 0)**   | **평균0, 표준편차1의 표준정규분포 배열(m,n) 생성** |
|     **c = sigma * np.random.randn(5) + mu**     | **N(1, 0)이아닌  N(μ, σ2)**  |          **sigma : 표준편차, mu : 평균**           |
|       **np.random.standard_nomal((m,n))**       |   **표준정규분포N(1, 0)**    |   **randn()과 유사하지만 튜플을 인자로 받는다.**   |
| **np.random.normal(평균값, 분산, 데이터개수)**  |    **정규분포 N(μ, σ2)**     |        **정규분포를 가지는 데이터의 배열**         |
|          **np.random.random_sample()**          |          [0.0,1.0)           |   [0.0,1.0)범위에서 샘플링된 임의의 실수를 반환    |
|              **np.random.seed()**               | 난수 생성에 필요한 시드 설정 |                 동일한 난수가 생성                 |



