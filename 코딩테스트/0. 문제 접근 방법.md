# 문제에 접근하는 방법

## 문제 해결 방법론

### 1. 그리디
- 현재 상황에서 당장 좋은 것 만 고르는 방법 / 정당성 확보가 중요

- 정당성: 가장 좋은 것을 반복해도 항상 최적의 해가 나오는 상황

### 2. 구현

- 해결책(풀이)은 쉽지만, 코드로 옮기기 어려운 문제

### 3. 완전 탐색

- 모든 가능한 경우 수를 탐색하여 최적의 해를 구하는 겻

1. Brute-force: 무식한 힘 / 말 그대로 모든 경우의 수를 탐색
2. Bitmask: 모든 경우의 수를 '이진수'형태로 변경하여 비트 연산을 통한 최적의 해를 구하는 완전 탐색 기법
      1. 권한 관리: 각 권한 비트로 표현하여 하나의 정수값으로 나타낸다.
      1. 집합 관리: 집합을 비트로 표현하여 비트 연산을 통해 집합 포함 관계를 나타낸다.
      1. 상태: 여러 상태를 하나의 정수에 나타내어 관리
3. Backtracking: 해결책으로 가는 도중에 막히게 되면 그 지점으로 돌아가서 다른 경로를 탐색하는 방식
4. 순열: 순열을 이용하여 모든 경우 수를 탐색
      1. swap 배열 : 배열 인덱스 0 부터 순서대로 선택하면서 다음 인덱스와 위치를 바꾸고 마지막 인덱스 까지 반복
            1. 특정 값을 fix하고 이후 값들을 반복문으로 swap
      2. Visted 배열: 배열에서 '현재 인덱스 값을 선택한 후' 해당 인덱스를 visited라는 배열에 체크합니다.
            1. 한 loop내에서 해당 인덱스가 visited이면 다음 최소 인덱스로 넘어간다.
5. 재귀함수:
      1. 자기 내부에서 자기 자신을 호출하는 함수
      2. 때때로 완전 탐색이 아닌 비완전 탐색일 수 도 있다.
6. DFS/ BFS
      1. DFS: 깊이 우선 탐색
            1. 루트 노드에서 시작하며 **다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색**하는 방법
            2. 스택 또는 재귀 방식을 선택
      2. BFS: 너비 우선 탐색
            1. 루트노드에서 시작하여 **인접한 노드를 먼저 탐색**
            2. 큐를 사용
            3. 최단 경로 탐색에 사용

### 4. 다이나믹 프로그래밍

1. 정의: 이미 계산된 결과는 **별도의 영역에 저장하여 다시 계산하지 않으므로 수행시간의 효율성을 올리는 기법**

2. 조건

      1. **최적 부분 구조**: 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 최적의 답을 모아서 큰 문제를 해결 가능
      2. **중복 부분 문제:** 동일한 작은 문제들이 반복하여 나타나는 경우(재활용)

3. 구현

      1. **Top-down(재귀, Memoization)**
            1. dp[n]의 값을 찾기 위해 **위에서 부터 호출을 시작하여 dp[0]까지 내려간 다음 해당 결과 값을 재귀를 통해 전이하며 활용"

      2. **Bottom-up(반복문, Tabulation)**
            1. dp[n]을 찾기 위해 dp\[0](기저상태) 부터 출발하여 배열에 값을 채우는 Table-filling과정을 통해 dp[n] 값을 찾는다.

4. 분할 정복 vs 다이나믹 프로그랭

      1. 공통점: 

            1. 최적 부분 구조: 작은 문제로 여러 나눠서 최적의 답을 구한 후 큰 문제를 해결 가능하다.

      2. 차이점

            1. 중복 부분 구조

               1. 분할 정복: **부분 문제가 반복적 계산**이 아니다.

               2. DP: 부분 문제가 중복이 발생하고, 각 부분 문제들이 서로 영향을 미친다.

                  

## 문제 접근

1. 조건 확인
2. 주어진 예시 확인
3. **문제 해결 아이디어**
4. 구현
5. 테스트 케이스 통과
