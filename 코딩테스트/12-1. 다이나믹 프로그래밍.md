[toc]

# 다이나믹 프로그래밍(DP)

## 1. DP 개요

- 다이나믹 프로그래밍은 **메모리를 적절히 사용하여 수행시간 효율성을 비약적으로 향상시키는 방법** 입니다.
- <u>이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장</u>하여 다시 계산하지 않도록 합니다.
- 다이나믹 프로그래밍의 구현은 일반적으로 두 가지 방식(**탑다운과 보텀업**)으로 구성된다.
- **동적 계획법**이라고도 부릅니다.
- 일반적인 프로그래밍 분야에서의 동적이란 어떤 의미를 가질까요?
  - 자료구조에 동적 할당은 '프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법'을 의마합니다.
  - 반면에 다이나믹 프로그래밍에서 '다이나믹'은 **별다른 의미없이 사용된 단어** 입니다.

> **하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결 할 때 사용**



## 2. DP를 쓰는 이유

사실 일반적인 재귀 도한 DP와 매우 유사하다. 큰 차이점은 **일번적인 재귀를 단순히 사용 시 동일한 작은 문제들이 여러번 반복되어 비효율적인 계산**될 수 있다는 것입니다.

예를 들어 피보나치 수열을 살펴보자. 피보나치 수열은 아래와 같다.
1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144 ...

피보나치 수를 구하고 싶을 때 재귀로 함수를 구성하면 어떻게 될까? 단순하다. return f(n) = f(n-1) + f(n-2)

그런데 f(n-1), f(n-2)에서 각 함수를 1번씩 호출하면 동일한 값을 2번씩 구하게 되고 이로 인해 100번째 피보나치 수를 구하기 위해 호출되는 함수의 횟수는 기하급수 적으로 증가한다.(약 **7해, #,###경 #,###조 ... 번 이상 함수 호출**, 컴퓨터도 죽는다.)

왜냐하면, f(n-1)에서 한 번 구한 값을 f(n-2)에서 또 다시 같은 값을 구하는 과정을 반복하게 되기 때문이다. 아래의 그림처럼 반복되는 계산을 또 하게 된다.

![img](https://blog.kakaocdn.net/dn/t3PF0/btqSgLZbXTp/dRqSxgLwa4padvt3qtAqNk/img.png)

그러나 한 번 구한 작은 문제의 결과 값을 저장해두고 재사용 한다면 어떨까? 앞에서 계산된 값을 다시 반복할 필요가 없이 약 200회 내에 계산이 가능해집니다.

즉, 매우 효율적으로 문제를 해결할 수 있게 됩니다. 시간복잡도를 기준으로 아래와 같이 개선이 가능합니다.
**O(n^2) → O(f(n)) 로 개선** (다항식 수준으로, 문제에 따라 다름.)

##  3. 다이나믹 프로그래밍의 조건

- 다이나믹 프로그래밍은 문제가 다음의 조건 만족시 사용할 수 있습니다.
  1. **최적 부분 구조(Optimal Substructure)**
  
     **큰 문제를 작은 문제로 나눌 수 있으며  작은 문제의 최적의 답을 모아서 큰 문제의 최적의 답을 해결**할 수 있다.
  
     그래서 특정 문제의 정답은 문제의 크기에 상관없이 항상 동일하다.
  
     만약, A-B까지의 가장 짧은 경로를 찾고자 하는 경우를 예시로 할 때, 중간에 X가 있을 때, A-X/X-B가 많은 경로중 가장 짧은 경로라면 전체 경로도 A-X-B가 정답이 된다.
  
     ![img](https://blog.kakaocdn.net/dn/dfnwTm/btqSsRROqcY/GAZup1WSsVUWsh70ohfWb0/img.png)
  
     위의 그림에서 A - X 사이의 최단 거리는 AX2이고 X - B는 BX2이다. 전체 최단 경로는 AX2 - BX2이다. 다른 경로를 택한다고 해서 전체 최단 경로가 변할 수는 없다.
  
     이와 같이, 부분 문제에서 구한 최적 결과가 전체 문제에서도 동일하게 적용되어 결과가 변하지 않을때 DP를 사용할 수 있게 된다.
  
     > **부분 문제의 최적 결과값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우**를 의미한다.
  
  2. **중복되는 부분 문제(Overlapping Subproblem)**
  
     DP는 기본적으로 문제를 나누고 그 문제의 결과 값을 재활용해서 전체 답을 구합니다. 그래서 **동일한 작은 문제들이 반복하여 나타나는 경우 사용이 가능**합니다.
  
     > 해당 부분 문제가 반복적으로 나타나지 않는다면 재사용(저장된 결과)이 불가하니 **부분 문제가 중복되지 않는 경우에는 사용할 수 없다.**



## 4. DP 사용하기

DP는 특정한 경우에 사용하는 알고리즘이 아니라 **하나의 방법론**이므로 다양한 문제해결에 쓰일 수 있다. 그래서 DP를 적용할 수 있는 문제인지를 알아내는 것부터 코드를 짜는 과정이 난이도가 쉬운 것부터 어려운 것까지 다양하다.

일반적으로 DP를 사용하기 전에는 아래의 과정을 거쳐 진행할 수 있다.

1. DP로 풀 수 있는 문제인지 확인한다.
2. 문제의 변수 확인
3. 변수 간 관계식 만들기**(점화식)**
4. 메모하기(memoization or tabulation)
5. 기저 상태 파악하기
6. 구현하기

#### 1. DP로 풀 수 있는 문제인지 확인

---

현재 직면한 문제가 작은 문제들로 이루어진 하나의 함수로 표현될 수 있는지를 판단해야 한다.

즉, 위에서 쓴 **조건들이 충족되는 문제인지를  한 번 체크**해보는 것이 좋다.

보통 특정 데이터 내 최대화/최소화 계산을 하거나 특정 조건 내 데이터를 세야 한다거나 확률 등의 계산의 경우 DP로 풀 수 있는 경우가 많다.



#### 2. 문제의 변수 파악

---

DP는 현재 변수에 따라 그 **결과 값을 찾고** 그것을 전달하여 **재사용**하는 것을 거친다. 즉, 문제 내 변수의 개수를 알아야 한다는 것. 이것을 영어로 "state"를 결정한다고 한다.

예를 들어, 피보나치 수열에서는 n 번째 숫자를 구하는 것이므로 n이 변수가 된다. 그 변수가 얼마이냐에 따라 결과값이 다르지만 그 결과를 재사용하고 있더.

또한, 문자열 간의 차이를 구할 때는 문자열의 길이, Edit거리 등 2가지 변수를 사용한다.

또, **Knapsack문제**에서는 index, 무게로 2가지의 변수를 사용한다. 이와 같이 해당 문제에서 어떤 변수가 있는 지를 파악해야 그에 따른 답을 구할 수 있다.



#### 3. 변수 간 관계식 만들기

---

변수들에 의해 결과 값이 달라지지만 **동일한 변수값인 경우 결과는 동일하다**. 또한 우리는 그결과값을 그대로 이용할 것이므로 그 관계식을 만들어 낼 수 있다.

그러한 식을 **점화식**이라고 부르며 그를 통해 우리는 짧은 코드 내에서 반복/재귀를 통해 문제가 자동으로 해결되도록 구축할 수 있게 된다.

예를 들어 피보나치 수열에서는 **f(n) = f(n-1) + f(n-2)** 였다. 이는 변수의 개수, 문제의 상황마다 모두 다를 수 있다.



#### 4. 메모하기(결과 저장 / Memoization)

---

변수 간 관계식까지 정상적으로 생성되었다면 **변수의 값에 따른 결과를 저장**해야한다. 이것을 메모한다고 하여 **Memoization**이라고 부른다.

변수 값에 따른 결과를 저장할 배열 등을 미리 만들고 그 결과를 나올 때마다 배열 내에 저장하고 그 저장된 값을 재사용하는 방식으로 문제를 해결해 나간다.

이 결과 값을 저장할 때는 보통 배열을 쓰며 변수의 개수에 따라 배열의 차원이 1~3차원 등 다양할 수 있다.



#### 5. 기저 상태 파악하기

---

여기까지 진행했으면, **가장 작은 문제의 상태를 알아야 한다.** 보통 몇 가지 예시를 직접 손으로 테스트하여 구성하는 경우가 많다.

피보나치 수열을 예시로 들면, **f(0) = 0, f(1) = 1**과 같은 방식이다. 이후 두 가지 숫자를 더해가며 값을 구하지만 가장 작은 문제는 저 2개로 볼 수 있다.

해당 기저 문제에 대해 파악 후 미리 배열등에 저장해 두면 된다. 이 경우, 피보나치 수열은 매우 간단했지만 문제에 따라 좀 복잡할 수 있다.



#### 6. 구현하기

---

개념과 DP를 사용하는 조건, DP 문제를 해결하는 과정도 익혔으니 실제로 어떻게 사용할 수있는지를 알아보고자 한다. DP는 두가지 방식으로 구현할 수 있다.



1) **Bottom-UP(Tabulation) - 반복문 사용**
2) **Top-Down(Memoization) - 재귀 사용**



1. ##### **Bottom up 방식(Tabulation)**

   이름에서 보이듯이, 아래에서부터 계산을 수행하고 누적시켜서 전체 큰 문제를 해결하는 방식이다.

   메모를 위해서 dp라는 배열을 만들었고 이것이 1차원이라 가정했을 때, dp[0]가 기저 상태이고, dp[n]을 목표 상태라고 하자. Bottom-up은 dp[0]부터 시작하여 반복문을 통해 점화식으로 결과를 내서 dp[n]까지 그 값을 전이시켜 재활용하는 방식이다.

   **왜 Tabulation?**

   사실 위에서 메모하기 부분에서 Memoization이라고 했는데 Bottom-up일 때는 Tabulation이라고 부른다. 왜냐면 **반복을 통해 dp[0]부터 하나 하나씩 채우는 과정**을 **"table-filling"** or caching 하며, 이 **Table**에 저장된 값에 직접 접근하여 재활용하므로 **Tabulation**이라는 명칭이 붙었다고 한다.

   사실상 근본적인 개념은 결과값을 기억하고 재활용한다는 측면에서 메모하기(Memoization)와 크게 다르지 않다.

   

2. ##### Top-Down 방식

   이는 dp[0]의 기저 상태에서 출발하는 대신 dp[n]의 값을 찾기 위해 **위에서 부터 바로 호출을 시작**하여 dp[0]의 상태까지 내려간 다음 **해당 결과 값을 재귀를 통해 전이시켜 재활용하는 방식**이다.

   피보나치의 예시처럼, f(n) = f(n-2) + f(n-1)의 과정에서 함수 호출 트리의 과정에서 보이듯, n=5일 때, f(3), f(2)의 동일한 계산이 반복적으로 나오게 된다.

   이때, 이미 이전에 계산을 완료한 경우에는 단순히 메모리에 저장되어 있던 내역을 꺼내서 활용하면 된다. 그래서 가장 최근의 상태 값을 메모해 두었다고 하여 Memoization이라고 부른다.

   

## 5. 대표문제

#### 1. 피보나치 수열

- 피보나치 수열 다음과 같은 형태의 수열이며, 다이나믹 프로그래밍으로 효과적으로 계산

$$
1, 1, 2, 3, 5, 6, 13, 21, 34, 55, 89
$$

- **점화식**이란 인접한 항들 사이의 관계식을 의미합니다.

- 피보나치 수열을 점화식으로 표현하면 다음과 같습니다.

- $$
  a_n = a_{n-1}+a_{n-2}, a_1 =1, a_2 = 1
  $$

```python
import math
import time
#DP를 사용시 작은 문제의 결과값을 저장하는 배열
# Top-down, Bottom-up 방식 별개로 생성

def fibo(x):
    if x == 0 or x == 1:
        return x
    return fibo(x-1) + fibo(x-2)

# Top-down(Memoization) - 재귀
def topdown(n): #topdwon 방식 / memo /
    #기저 상태 도달시, 0과 1로 초기화
    global topdown_memo
    if n < 2:
        topdown_memo[n] = n
        return topdown_memo[n]

    # memo에 계산된 값이 있으면 바로 반환
    if(topdown_memo[n] > 0):
        return topdown_memo[n]

    # memo에 값이 없다면 계산(재귀)
    topdown_memo[n] = topdown(n-1) + topdown(n-2)
    return topdown(n)

# Bottom-up(Tabulation)방식 - table-filling / 반복문
def bottomup(n):
    global bottomup_table
    bottomup_table[0] = 0
    bottomup_table[1] = 1

    for i in range(2, n+1):
        # table을 채워나감
        bottomup_table[i] = bottomup_table[i-1] + bottomup_table[i-2]

    return bottomup_table[n]


n = int(input())
startTime = time.time()
print(fibo(n))
endTime = time.time()
print(f"걸린시간 : {endTime-startTime:.5f}" )

topdown_memo = [0] * (n+1)
bottomup_table = [0]* (n+1)

startTime = time.time()
print(topdown(n))
endTime = time.time()
print(f"걸린시간 : {endTime-startTime:.5f}" )

startTime = time.time()
print(bottomup(n))
endTime = time.time()
print(f"걸린시간 : {endTime-startTime:.5f}" )

"""출력
30
832040
걸린시간 : 0.13902
832040
걸린시간 : 0.00000
832040
걸린시간 : 0.00000
"""
```



피보나치 수열의 시간복잡도

- 빅오 표기법: $O(2^n)$
- 빅오 표기법을 기준으로 $f(30)$을 계산하기 위해 약 10억가량의 연산을 수행
- DP를 사용하여 시간복잡도를 줄인다.

Memozation을 호출 시 피보나치 수열 함수의 시간복잡도는 $O(N)$입니다.



## 6. 다이니믹 프로그래밍 vs 분할 정복

- 다이니믹 프로그래밍과 분할 정복은 모두 **최적 부분 구조**를 가질 때 사용할 수 있습니다.
  - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황
  
- DP와 분할 정복의 차이점은 **부분 문제의 중복**입니다.
  - DP 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복됩니다.
  
  - 분할 정복 문제에서는 동일한 **부분 문제가 반복적으로 계산되지 않습니다.**
  
    

## 7. 문제에 접근하는 방법

- 주어진 문제가 **다이나믹 프로그래밍 유형**임을 파악하는 것이 중요합니다.
- 가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는 지 검토 합니다.
  - 다른 알고리즘 방법이 떠오르지 않는다면 다이나믹 프로그래밍을 고려해봅시다.
- 일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에 (탐다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 코드를 개선하는 방법을 사용할 수 있습니다.
- 일반적인 코딩 테스트 수준에서는 기본 유형의 다이나믹 프로그래밍 문제가 출제되는 경우가 많습니다. 
