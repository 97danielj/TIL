# 정렬 알고리즘

---

- 정렬이란 **데이터를 특정한 기준에 따라 순서대로 나열**하는 것

- 일반적으로 **문제 상황에 따라 적절한 정렬 알고리즘이 공식처럼 사용**

## 1. 선택 정렬

- 처리 되지 않은 데이터 중에서 **가장 작은 데이터를 <u>선택</u>해 맨 앞에 있는 데이터와 바꾸는 것을 반복 **
- i는 선택한 데이터 파티션의 맨 앞 원소의 인덱스
- **시간복잡도**
  - 선택정렬은 N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 합니다.
  - 전체 연산 횟수는 다음과 같습니다.
    - $N + (N-1) + (N-2)+...+2$
    - 이는 빅오 표기법에 따라서 $O(N^2)$

```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    min_index = i #가장 작은 원소의 인덱스
    for j in range(i+1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
    array[i], array[min_index] = array[min_index], array[i] #스와프(가장 작은 수를 맨 앞의 위치와 교환)
    
print(array)
```

## 2. 삽입 정렬

- 처리되지 않은 데이터를 하나씩 골라 **적절한 위치에 <u>삽입</u>**합니다.
- 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효울적으로 동작
- **앞쪽에 있는 원소들이 정렬되어 있다고 판단**하고, 뒤쪽 원소 위치 판단
  - 첫번째 원소는 이미 정렬되어 있다고 판단 => 두번째 원소부터 시작
  - j는 삽입할 원소의 인덱스

- 시간복잡도
  - $O(N^2)$, 선택정렬과 마찬가지로 반복문이 두번 중첩
  - 삽입정렬은 <u>현재 리스트의 데이터가 거의 정렬 되어 있는 상태라면 매우 빠르게 동작</u> 
    - 최선의 경우 $O(N)$
- 코드

```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array)):
    for j in range(i, 0, -1): #인덱스 i부터 1까지 1씩 감소하며 반복하는 문법
        if array[j] < array[j-1]: #한칸씩 왼쪽으로 이동
            array[j], array[j-1] = array[j-1], array[j]:
        else:
            break          
print(array)
```



## 3. 퀵 정렬

- <u>기준 데이터를 설정(pivot)</u>하고 그 기준보다 **큰 데이터와 작은 데이터의 위치**를 바꾸는 방법입니다.
- 일반적 상황 가장 많이 사용되는 정렬 알고리즘 중 하나
- 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘
- 가장 기본적인 퀵 정렬은 **첫 번째 데이터를 기준 데이터(Pivot)**로 설정합니다.
- 퀵 정렬의 순서
  - 가장 왼쪽 값을 pivot값으로 설정
  - 왼쪽에서 pivot보다 작은 값을 선택, 오른족에서 pivot보다 큰 값을 선택
  - 두 데이터의 위치를 서로 변경합니다.
  - 단, **위치가 엇갈리는 경우 'pivot'과 '작은 데이터'의 위치를 서로 변경**합니다.
  - 이렇게 <u>피벗을 기준으로 데이터 묶음을 나누는 작업</u>을 분할(Divide)이라고 합니다.
  - 이러한 과정을 재귀적으로 계속해서 수행하게 되면 전체 데이터에 대해서 정렬이 완료될 것입니다. 

- 퀵 정렬이 빠른 이유
  - 이상적인 경우 분할이 절반 씩 일어난다면 전체 연산 횟수로 $O(NlogN)$를 기대할 수 있습니다.
  - 너비 * 높이 = N * $logN$
- 시간 복잡도
  - 평균의 경우 $O(NlogN)$
  - 하지만 최악의 경우 $O(N^2)$의 시간 복잡도를 가집니다.
    - **이미 정렬된 배열에 대하여 퀵 정렬을 수행 시** 
    - 분할을 위해 계속적 선형 탐색을 하는 경우(높이 $N$)

- 소스코드 - 1

```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end):
    if start >= end: #원소가 1개인 경우
        return
    pivot = start # 피벗은 첫 번째 원소
    left = start + 1
    right = end
    while(left <= right):
        # 피벗보다 큰 데이터를 찾을 때 까지 반복
        while(left <= end and array[left] <= array[pivot]):
            left += 1
        # 피벗보다 작은 데이터를 찾을 때 까지 반복
        while(right > start and array[right] >= array[pivot]):
            right -= 1
        if(left > right): # 엇갈렸다면 작은 데이터와 피벗을 교체
            array[right], array[pivot] = array[pivot], array[left]
        else: #엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
            array[right], array[left] = array[left], array[right]
        # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
    quick_sort(array, start, right-1)
    quick_sort(array, right+1, end)

quick_sort(array, 0, len(array)-1)
print(array)

        
            
```

- 소스코드 - 2 리스트 컨프리헨션 사용

```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
def quick_sort(array):
    if len(array) <= 1:
        return array
    pivot = array[0]
    tail = array[1:]
    
    left_side = [x for x in tail if x <= pivot]
    right_side = [x for x in tail if x > pivot]
    
    return quick_sort(left_side) + [pivot] + quick_sort(right_side)
print(quick_sort(array))
```



### 4. 계수 정렬

- 특정 조건이 부합할 때만 사용할 수 있지만 **매우 빠르게 동작하는 정렬 알고리즘**
  - 계수 정렬은 **데이터의 크기 범위가 제한**되어 정수 형태로 표현할 수 있을 때 사용가능합니다.
- 데이터의 개수가 N, 데이터(양수) 중 최대 값이 K일 때 최앗의 경우에도 수행 시간 $O(N+K)$를 보장합니다.
- 즉 계수기가 필요하다  
- 개수 정렬은 동일한 값을 가지는 데이터가 여러 개 등장할 때 효과적으로 사용할 수 있습니다.



### 5. 정렬 알고리즘

- 앞서 다룬 네가지 정렬 알고리즘을 비교하면 다음과 같습니다.
- 추가적으로 대부분의 프로그래밍 언어에서 지원하는 **표준 정렬 라이브러리는 최악의 경우에도 **$O(NlogN)$을 보장하도록 설계되어 있습니다.

| 정렬 알고리즘 | 평균 시간 복잡도 | 공간 복잡도 | 특징                                                         |
| ------------- | ---------------- | ----------- | ------------------------------------------------------------ |
| 선택 정렬     | $O(N^2)$         | $O(N)$      | 아이디어가 매우 간단합니다.                                  |
| 삽입 정렬     | $O(N^2)$         | $O(N)$      | 데이터가 거의 정렬되어 있을 때는 가장 빠릅니다.              |
| 퀵 정렬       | $O(NlogN)$       | $O(N)$      | 대부분의 경우에 가장 적합하며, 충분히 빠릅니다.              |
| 계수 정렬     | $O(N+K)$         | $O(N+K)$    | 데이터의 크기가 한정되어 있는 경우에만 사용이 가능하지만 매우 빠르게 동작합니다. |



