# 정렬 알고리즘

---

- 정렬이란 **데이터를 특정한 기준에 따라 순서대로 나열**하는 것

- 일반적으로 **문제 상황에 따라 적절한 정렬 알고리즘이 공식처럼 사용**

## 1. 선택 정렬

- 처리 되지 않은 데이터 중에서 **가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복 **

- **시간복잡도**
  - 선택정렬은 N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 합니다.
  - 전체 연산 횟수는 다음과 같습니다.
    - $N + (N-1) + (N-2)+...+2$
    - 이는 빅오 표기법에 따라서 $O(N^2)$



## 2. 삽입 정렬

- 처리되지 않은 데이터를 하나씩 골라 **적절한 위치에 삽입**합니다.
- 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효울적으로 동작
- 앞쪽에 있는 원소들이 정렬되어 있다고 판단하고, 뒤쪽 원소 위치 판단
- 시간복잡도
  - $O(N^2)$, 선택정렬과 마찬가지로 반복문이 두번 중첩
  - 삽입정렬은 <u>현재 리스트의 데이터가 거의 정렬 되어 있는 상태라면 매우 빠르게 동작</u> 
    - 최선의 경우 $O(N)$
    - 

## 3. 퀵 정렬

- 기준 데이터를 설정하고 그 기준보다 **큰 데이터와 작은 데이터의 위치**를 바꾸는 방법입니다.
- 일반적 상황 가장 많이 사용되는 정렬 알고리즘
- 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘
- 가장 기본적인 퀵 정렬은 **첫 번째 데이터를 기준 데이터(Pivot)**로 설정합니다.
- Pivot을 기준으로 파티션 2개가 나눠지는데 이러한 작업을 분할 작업이라 합니다.
- 이러한 과정을 파티션에 관해 반복 수행하면 전체 데이터에 대한 정렬이 수행됩니다.
- 퀵 정렬이 빠른 이유
  - 이상적인 경우 분할이 절반 씩 일어난다면 전체 연산 횟수로 $O(NlogN)$를 기대할 수 있습니다.
  - 너비 * 높이
- 시간 복잡도
  - 평균의 경우 $O(NlogN)$
  - 하지만 최악의 경우 $O(N^2)$의 시간 복잡도를 가집니다.
    - **이미 정렬된 배열에 대하여 퀵 정렬을 수행 시** 

```python
def quick_sort(array):
    if len(array)<= 1:
        return array
    pivot = array[0]
    tail = array[1:]
    
    left_side = [x for x in tail if x < pivot]
    right_side = [x for x in tail if x > pivot]
    
    return quick_sort(left_side)+[pivot]+quick_sort(right_side)
print(quick_sort(array))
```

