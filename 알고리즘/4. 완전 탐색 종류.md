[toc]

# 완전 탐색 종류

---

## 0. 완전 탐색

- 알고리즘에서 사용되는 기법 중 하나로 **'모든 가능한 경우의 수를 탐색'하여 '최적의 결과를 찾는 방법'을 의미합니다.**

![img](https://blog.kakaocdn.net/dn/bq0hsG/btsitAwRa2N/52DrrDlkvOmEyM3DYpe5UK/img.png)

```tex
💡 미 완전 탐색은 무엇일까?
- 모든 경우의 수를 고려하지 더 이상 탐색이 필요 없는 경우 그 루트를 끊어버리는 것을 의미합니다.
- 예를 들어서 재귀함수가 함수를 모든 경우의 수를 탐색하다 결과를 찾아서 탐색을 중지하는 경우 루트를 끊는 경우를 자치기(Pruning)라고 합니다. 이를 수행하면 불필요한 탐색을 줄일 수 있습니다.
```

## 1. 브루트 포스(Brute-Force)

- 난폭한 힘, 폭력 => 무식하지만 확실한 방식을 의미
- 이는 수행하는데 오래걸리는 데다 자원이 많이 소요되지만 이론적으로 가능한 수를 모두 검색하기에 예상된 결과를 얻을 수 있습니다.
- **'모든 경우를  다 탐색'하면서 결과를 얻는 알고리즘을 의미합니다.**
- 해당 알고리즘은 경우의 수가 작을 때 사용하는 것이 일반적입니다. 대표적인 예시로는 자물쇠의 비밀번호를 알 수 없는 경우 모든 경우를 대입하여 비밀번호를 찾아가는 경우가 있습니다.

```tex
💡 완전 탐색에서 브루트 포스란?
모든 경우의 수를 탐색하여 최적의 결과를 찾아가는 완전탐색에서 브루트 포스는 모든 경우를 다 검사하여 원하는 값을 탐색하는 방법입니다.

💡 브루트 포스를 이용한 공격방식이란?
해커들은 이 알고리즘을 이용하여 다양한 공격을 시도합니다. 예를 들어, 로그인 페이지에서 사용자 이름과 비밀번호를 입력하여 로그인하는 경우 해커들은 브루트 포스 알고리즘을 이용하여 가능한 모든 비밀번호를 시도하면서 로그인을 시도합니다. 이러한 공격을 방지하기 위해서는 강력한 비밀번호를 사용하고 로그인 시도 횟수를 제안하는 등의 보안 조치를 취해야 합니다.
```

### 브루터 포스 사용 예시

1. 배열 탐색

   - 배열에서 특정 값을 찾는 문제에서 브루트 포스 알고리즘은 배열을 모두 탐색하여 값을 찾는 방식으로 문제를 해결합니다.

    ```python
     def findIndex(arr, target):
         for i in range(len(arr)):
             if arr[i] == target:
                 return i
         return -1
    ```

2. 문자열 비교

   - 문자열 비교 문제에서 브루트 포스 알고리즘은 가능한 모든 문자열 쌍을 비교하여 최소값 또는 최대값을 찾는 방식으로 문제를 해결합니다.

   ```python
   def stringCompare(s1, s2):
       length_s1 = len(s1)
       length_s2 = len(s2)
   
       small_length = min(length_s1, length_s2)
   
       for i in range(small_length):
           if s1[i] != s2[i]:
               return ord(s1[i]) - ord(s2[i])
   
       if (length_s1 == length_s2):
           return 0
       elif length_s1 > length_s2:
           return s1[small_length]
       else:
           return s2[small_length]
   ```

## 2. 비트마스크(Bitmask)

- **'이진수'를 '비트 연산'을 통해 경우의 수를 줄여가며 탐색하는 방식을 의미합니다.**

- 모든 경우의 수(상태)를 이진수로 표현

- 비트 마스크를 사용하면 **하나의 변수에 여러개의 상태정보를 저장**할 수 있으며 이를 통해 복잡한 조건문을 간단하게 처리할 수 있습니다.

- 이 방법은 비트 연산을 사용하기 때문에 빠르게 계산할 수 있어서, 경우의 수가 많은경우에 유용합니다.

  ```tex
  💡 완전 탐색에서 비트마스크란?
  모든 경우의 수를 탐색하여 최적의 결과를 찾아가는 완전탐색에서 비트마스크는 모든 경우의 수를 이진수로 표현하여 빠르게 계산을 해 나아가는 방식입니다.
  ```

### 간단한 연산

```python
a = 10 #1010
b = 12 #1100

result = a & b
result = a | b
result = a ^ b # XOR 연산
result = a << 1
result = a >> 1
```

### 비트마스크 사용 예시

1. 권한 관리

   보통 권한은 4가지 이상으로 구분되어 있는 경우가 많습니다. 이때 **각 권한을 비트**로 표현하여 하나의 정수값으로 나타내면 매우 간편해집니다.

   ```python
   PERMISSION_READ = 0b0001 << 0; # 0001
   PERMISSION_WRITE = 0b0001 << 1; # 0010
   PERMISSION_DELETE = 0b0001 << 2; # 0100
   PERMISSION_EXECUTE = 0b0001 << 3; # 1000
   
   print(PERMISSION_EXECUTE)
   userPermission = PERMISSION_READ | PERMISSION_WRITE
   print(userPermission)
   groupPermission = PERMISSION_READ | PERMISSION_EXECUTE
   
   hasReadPermission = (userPermission & PERMISSION_READ) != 0
   print(hasReadPermission)
   hasDeletePermission = groupPermission & PERMISSION_DELETE != 0
   print(hasDeletePermission)
   #출력문
   #8
   #3
   #True
   #False
   ```

2. 집합 관리

   **집합을 비트로 표현**하여 메모리를 절약할 수 있습니다. 예를들어, 0부터 31까지의 정수 중에서 3, 5, 7번째 원소를 포함하는 집합을 나타내면 다음과 같이 표현할 수 있습니다.

   ```python
   set = (1 << 3) | (1 << 5) | (1 << 7) #1010 1000
   hasElement5 = (set & (1 << 5)) != 0; #True
   hasElement6 = (set & (1 << 6)) != 0; #False
   ```

3. 상태 플래그 관리

   **여러 상태를 하나의 정수값**으로 나타내어 관리할 수 있다. 예를 들어, 주어진 수가 2의 거듭제곱인지 여부를 판단할 때 다음과 같은 방법을 사용할 수 있습니다.

   ```python
   FLAG_POWER_OF_TWO = 1 << 0; #0001
   FLAG_NEGATIVE = 1 << 1; #0010
   
   number = 8; # 2의 거듭제곱
   flags = 0;
   
   if number & (number-1) == 0 :
       flags |= FLAG_POWER_OF_TWO
   
   
   if (number < 0):
       flags |= FLAG_NEGATIVE
       print(flags)
   
   
   if ((flags & FLAG_POWER_OF_TWO) != 0):
       print(number, " is power of two") #1
   
   if ((flags & FLAG_NEGATIVE != 0)):
       print(number, "is negaive") # 2
   ```

## 3. 백트래킹(Backtracking)

- **해결책으로 가는 도중에 막히게 되면 그 지점으로 다시 돌아가서 다른 경로를 탐색하는 방식**을 의미합니다. 이를 통해 모든 가능한 경우의 수를 탐색하여 해결책을 찾습니다.

- 해당 알고리즘을 사용할 때 주로 재귀함수를 사용하여 구현하며 스택을 이용하여서 사용하는 경우도 있습니다.

- 재귀함수를 이용하는 경우 해결책을 찾기 위해 생성, 검사, 선택, 이동, 되돌아가기 등 과정이 재귀적으로 수행됩니다.

  ```tex
  💡완전탐색에서 백트래킹이란
  - 모든 경우의 수를 탐색하여 최적의 결과를 찾아가는 완전탐색에서 백트래킹은 해결책을 찾아가는 도중에 막히게 되면 다시 돌아가서 다른 경로로 탐색을 하여 결국 모든 가능한 경우의 수를 탐색하여 해결책을 찾아가는 방식으로 사용됩니다.
  - 주로 재귀함수, 스택이 이용됩니다.
  ```

## 4. 순열 탐색

- **'순열'을 이용하여 모든 경우의 수를 탐색하는 방법입니다.** 순열은 서로 다른 서로 다른 n개 중에서 r개를 선택하여 숫자를 모든 순서대로 뽑는 경유를 말합나다.

- 순열의 예

  - 1, 2, 3, 세 숫자 중 '2개를 선택' 하여 숫자를 모든 순서대로 뽑는 경우입니다.

  - ```python
    [1,2]
    [1,3]
    [2,1]
    [2,3]
    [3.1]
    ```

  #### 1. Swap 배열을 이용한 순열

  - Swap 배열

    - 배열에서 **두 요소의 위치를 바꿔가며 순열을 생성하는 방법**입니다. 배열의 인덱스 0 부터 순서대로 선택하면 다음 인덱스와 위치를 바꾸고 이를 마지막 인덱스 까지 반복합나다.
    - 이 방법은 쉽게 구현할 수 있지만, 큰 데이터셋에서는 비효율적일 수 있습니다.
    - ![img](https://blog.kakaocdn.net/dn/Soikw/btsitSDZ7bX/cFn6cmAeMRetkgw8Emaa51/img.png)

  - ```tex
    [1, 2, 3]배열에서 순열을 모두 구하는 예시입니다.
    1. 메인함수에서 permute메서드에 파라미터로 배열과 0개를 선택합니다.
    2. permute메서드는 재귀적으로 호출하면서 swap 메서드를 이용하여 배열의 원소를 순서대로 바꾸면서 모든 순열을 생성합니다.
    3. 이때, k는 순열을 생성할 위치를 의미합니다. 만약 k가 arr의 길이와 같아지면, 모든 원소에 대한 순열이 생성되었다는 것을 의미하므로 순열을 출력합니다.
    ```

  - ```python
    class Permutation():
        # permute: 순열의 로직을 수행합니다.
        def permute(self, arr, k):
            for i in range(k, len(arr)):
                self.swap(arr, i, k)
                self.permute(arr, k+1)
                self.swap(arr, k, i)
    
            if (k == len(arr)-1):
                print(arr)
    
        # swap: 배열의 요소 값을 Swap 합니다.
        def swap(self, arr, i, j):
            """
    
            :param arr: 배열
            :param i: 현재 인덱스
            :param j: 바꿀 인덱스
            :return:
            """
            tmp = arr[i]
            arr[i] = arr[j]
            arr[j] = tmp
    
    
    def main():
        arr = [1, 2, 3, 4]
        p = Permutation()
    
        p.permute(arr, 0)
    
    
    if __name__ == '__main__':
        main()
    ```
    
    >
    >
    >즉, 순열에서 특정 값을 fix 시키고 이후의 값들을 swap 하면서 순열을 생성한다.
    
    ```tex
    💡 완전 탐색에서 순열은?
    
    - 모든 경우의 수를 탐색하여 최적의 결과를 찾아가는 완전탐색에서 순열은 서로 다른 n개 중에서 r개를 선택해서 나열하면서 모든 경우의 수를 탐색하는 방식으로 사용이 됩니다.
    ```
    
### 2.  Visited 배열을 이용한 순열

- **배열에서 '현재 인덱스의 값을 선택한 후' 해당 인덱스를 visited라는 배열에 체크합니다. 이후, 다음 인덱스로 넘어가기 전 visited 배열에서 체크되지 않은 가장 작은 인덱스를 선택합니다.** 이를 마지막 인덱스까지 반복합니다.
  
- 이 방법은 swap을 이용한 배열보다 효율적입니다.
  
    ![img](https://blog.kakaocdn.net/dn/bC6EiJ/btspgnq0M6q/TrBDculnz2tjywciQfOCE0/img.jpg)
    
    > 즉, 한 loop내에서 해당 인덱스가 Visited이면 다음 최소 인덱스로 넘어간다.



### 5. 재귀 함수(Recursion Function)

- **함수 내부에서 ‘자기 자신을 호출’하는 함수를 의미합니다.**

- 이를 통해서 함수가 자신을 반복적으로 호출하면서 원하는 결과를 도출할 수 있습니다.

  ```tex
  💡 완전 탐색에서 재귀함수는?
  
  - 모든 경우의 수를 탐색하여 최적의 결과를 찾아가는 완전탐색에서 재귀함수는 자기 자신을 호출하며 모든 가능한 경우를 체크하면서 최적의 해답하는 방법으로 사용이 됩니다.
  
  💡 재귀함수는 미 완전 탐색일 수도 있다?
  - 재귀함수는 모든 경우의 수를 다 탐색하지 않고도 원하는 결과를 얻을 수 있는 경우도 있습니다. 따라서, 재귀함수는 미완전탐색의 일종이라고는 할 수 있지만, 항상 미완전탐색이라고 할 수는 없습니다.(뿌리 자르기)
  ```

  

## 6. 깊이 우선 탐색(DFS) / 너비 우선 탐색(BFS)

- DFS, BFS은 비 선형 구조에서 주로 사용되며 선형 구조에서는 큰 의미를 갖지 않습니다.
- 깊이 우선 탐색이란?
  - 루트노드에서 시작하여 다음 분기로 넘어가기 전에 **해당 분기를 완벽하게 탐색하는 방법을 의미합니다.**
  - 해당 방식읜 자료구조의 '스택', '재귀'를 이용하여 구현할 수 있습니다.
- 너비 우선 탐색
  - 루트 노드에서 시작하여 **인접한 노드를 먼저 탐색**하는 방법
  - 해당 방식은 자료구조의 '큐'를 이용하여서 구현 가능합니다.

| **분류**         | **깊이 우선 탐색(DFS)** | **너비 우선 탐색(BFS)** |
| ---------------- | ----------------------- | ----------------------- |
| 자료구조         | 스택                    | 큐                      |
| 탐색방식         | 깊이 우선               | 너비 우선               |
| 최단 경로 탐색   | X                       | O                       |
| 재귀 구현 가능   | O                       | X                       |
| 반복문 구현 가능 | X                       | O                       |
| 메모리 사용량    | 적음                    | 많음                    |

